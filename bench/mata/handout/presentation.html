<!DOCTYPE html>
<html>
<head>
<style>
body {
        background-color: white;
}
pre.output {
    border-left-style: solid;
    width: 650px;
    max-height: 500px;
    overflow: auto;
    border-left-color:grey;
    border-width: 5px;
    background-color: #f0f0f0;
    padding: 0px 5px 0px 10px;
    margin: 0px auto 0px auto;
}
pre.code {
    border-left-style: solid;
    width: 650px;
    max-height: 500px;
    overflow: auto;
    border-left-color:grey;
    border-width: 5px;
    background-color: #f0f0f0;
    padding: 0px 5px 0px 10px;
    margin: 0px auto 0px auto;
}
pre.code:before {
    counter-reset: listing;
}
pre.code code {
  counter-increment: listing;
}
pre.code code::before {
  content: counter(listing) ". ";
  display: inline-block;
  width: 35px;
  padding-left: auto;
  margin-left: auto;
  text-align: right;
}
pre {
    margin: 0px;
}
div.slide { 
    max-width: 680px;
    display: block;
    padding: 5px;
    margin: 10px auto 10px auto;
    border-style: solid;
    border-width: 1px;
    background-color: white ;
}
div.txt { 
    margin: 0px auto 0px auto;
    max-width: 650px;
}
div.flex-container {
    display: flex;
    justify-content: space-around;
}
p.bottom {
    display: block;
    margin: 0px;
    text-align:center;
}
</style>
</head>
<body>
<div class="slide" id="presentation.smcl">
<div class="txt"><pre>
<br>
                                     <b> Mata</b>
<br>
                                 Maarten Buis
                            University of Konstanz
<br>
                              maarten.buis@uni.kn
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"> <a href="#index.smcl">index</a> <a href="#slide1.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="index.smcl">
<div class="txt"><pre>
<br>
                               <b>Table of content</b>
<br>
 
</pre>
<pre>
    <b>Basics of mata</b>
</pre>
<pre>
-------------------------------------------------------------------------------
</pre>
<pre>
        How is Mata different from Stata
</pre>
<pre>
</pre>
<pre>
           <a href="#slide1.smcl"> What is Mata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide2.smcl"> Mata and Stata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide3.smcl"> When to use which</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide4.smcl"> entering and leaving Mata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide5.smcl"> Try it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide6.smcl"> things persist between Mata sessions</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide7.smcl"> variables</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide8.smcl"> creating variables</a>
</pre>
<pre>
</pre>
<pre>
        matrix operations
</pre>
<pre>
</pre>
<pre>
           <a href="#slide9.smcl"> arithmatic</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide10.smcl"> elementwise operations</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide11.smcl"> Subscripting</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide12.smcl"> logic</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide13.smcl"> elementwise logic</a>
</pre>
<pre>
</pre>
<pre>
        precision
</pre>
<pre>
</pre>
<pre>
           <a href="#slide14.smcl"> binary versus decimal</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide15.smcl"> how a number is stored</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide16.smcl"> rounding errors: adding and subtracting</a>
</pre>
<pre>
</pre>
<pre>
        moving data between Stata and Mata
</pre>
<pre>
</pre>
<pre>
           <a href="#slide17.smcl"> reading data from Stata in Mata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide18.smcl"> storing data from Mata in Stata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide19.smcl"> views and subviews</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide20.smcl"> reading and writing matrices and macros from Stata</a>
</pre>
<pre>
</pre>
<pre>
               <a href="#slide21.smcl"> macros and scalars in Stata</a>
</pre>
<pre>
</pre>
<pre>
        Application: linear regression and instrumental variable regression
</pre>
<pre>
</pre>
<pre>
           <a href="#slide22.smcl"> linear regression: getting variables</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide23.smcl"> Try it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide24.smcl"> Parameter estimates</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide25.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide26.smcl"> The variance covariance matrix</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide27.smcl"> Try it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide28.smcl"> Export and display the results in Stata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide29.smcl"> Do it yourself</a>
</pre>
<pre>
 
</pre>
<pre>
    <b>Functions in Mata</b>
</pre>
<pre>
-------------------------------------------------------------------------------
</pre>
<pre>
        basics
</pre>
<pre>
</pre>
<pre>
           <a href="#slide30.smcl"> functions</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide31.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide32.smcl"> Conditional statements</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide33.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide34.smcl"> loops</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide35.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide36.smcl"> declare your variables</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide37.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide38.smcl"> Make your function part of a Stata program</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide39.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide40.smcl"> Turn it into an .ado file</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide41.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
        Linear regression and instrumental variable regression
</pre>
<pre>
</pre>
<pre>
           <a href="#slide42.smcl"> turn our Mata code into a function</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide43.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide44.smcl"> Turn it into a Stata program</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide45.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide46.smcl"> Turn it into a .ado file</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide47.smcl"> Do it yourself</a>
</pre>
<pre>
</pre>
<pre>
        Maximum likelihood: logit and Poisson regression
</pre>
<pre>
</pre>
<pre>
           <a href="#slide48.smcl"> Maximum Likelihood</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide49.smcl"> Maximum Likelihood in Mata</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide50.smcl"> do it yourself poisson</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide51.smcl"> include in Stata program</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide52.smcl"> do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide53.smcl"> Allow factor varialbes</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide54.smcl"> do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide55.smcl"> Starting values</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide56.smcl"> do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide57.smcl"> allow weights</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide58.smcl"> do it yourself</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide59.smcl"> Make an ado file</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide60.smcl"> do it yourself</a>
</pre>
<pre>
</pre>
<pre>
        Certification
</pre>
<pre>
</pre>
<pre>
           <a href="#slide61.smcl"> Certification script</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide62.smcl"> What is in a certification script</a>
</pre>
<pre>
 
</pre>
<pre>
    <b>Advanced data types in Mata</b>
</pre>
<pre>
-------------------------------------------------------------------------------
</pre>
<pre>
        Pointers
</pre>
<pre>
</pre>
<pre>
           <a href="#slide63.smcl"> What is a pointer</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide64.smcl"> Passing functions to functions</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide65.smcl"> Try it yourself: approximating a function with a linear
            spline</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide66.smcl"> Collecting different things under a single name</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide67.smcl"> Using pointers to create an irregular array</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide68.smcl"> Try it yourself: 3D array</a>
</pre>
<pre>
</pre>
<pre>
        associative array
</pre>
<pre>
</pre>
<pre>
           <a href="#slide69.smcl"> What is an associative array</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide70.smcl"> Example: a bibliography in Mata</a>
</pre>
<pre>
</pre>
<pre>
        struct
</pre>
<pre>
</pre>
<pre>
           <a href="#slide71.smcl"> What is a struct</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide72.smcl"> Try it yourself: approximating a function with a linear
            spline</a>
</pre>
<pre>
</pre>
<pre>
        class
</pre>
<pre>
</pre>
<pre>
           <a href="#slide73.smcl"> What is a class</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide74.smcl"> 3D array</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide75.smcl"> Try it yourself: approximating a function with a linear
            spline</a>
</pre>
<pre>
 
</pre>
<pre>
    <b>Build your own class</b>
</pre>
<pre>
-------------------------------------------------------------------------------
</pre>
<pre>
           <a href="#slide76.smcl"> The goal</a>
</pre>
<pre>
</pre>
<pre>
        Getting basic working code
</pre>
<pre>
</pre>
<pre>
           <a href="#slide77.smcl"> Counting words</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide78.smcl"> punctuation</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide79.smcl"> Capital letters</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide80.smcl"> Common "meaningless" words</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide81.smcl"> Finding the most common words</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide82.smcl"> Export the results to Stata</a>
</pre>
<pre>
</pre>
<pre>
        Turning it into a Mata class
</pre>
<pre>
</pre>
<pre>
           <a href="#slide83.smcl"> Getting started</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide84.smcl"> Passing parameters to our class</a>
</pre>
<pre>
</pre>
<pre>
           <a href="#slide85.smcl"> private and public</a>
</pre>
<pre>
</pre>
<pre>
        What next
</pre>
<pre>
</pre>
<pre>
           <a href="#slide86.smcl"> Next steps</a>
</pre>
<pre>
</pre>
<pre>
        Wrapping up
</pre>
<pre>
</pre>
<pre>
           <a href="#slide87.smcl"> Useful sources</a>
</pre>
<pre>
 
</pre>
<pre>
           <a href="#slide88.smcl"> References</a>
</pre>
<pre>
</pre>
</div>
</div>
<div class="slide" id="slide1.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                                 <b> What is Mata</b>
<br>
    Mata is a programming language, that works well with
        matrices
        strings
        Stata
<br>
    Stata reads instructions (commands) one line at the time
<br>
    Mata is compiled, making it faster
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#presentation.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide2.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide2.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                                <b> Mata and Stata</b>
<br>
    Stata is high level language, which means that we humans can focus on the
    big picture because a lot of the details have already been preprogrammed.
<br>
    For example, in Stata we can type <b>regress income female educ</b>, and we can
    think of this as a shorthand for the following conversation between me
    and Stata:
<br>
        <b>me</b>:  Hi Stata. I want to run a linear regression today
        <b>Stata</b>: Hi Maarten. Great, I know how to do that. What dependent
        variable do you want to use?
        <b>me</b>:  income
        <b>Stata</b>: OK, I found it. Do you want to use any independent variables?
        <b>me</b>:  Yes, female and educ
        <b>Stata</b>: Ok, I also found those. Do you want to limit the sample in any
        way? Do you want to use weights? Is there a specific type of standard
        error you wish to see?
        <b>me</b>:  No, I am good. You can start now.
        <b>Stata</b>: OK, here are your results.
<br>
    Mata is a lower level language, which means the humans have more control
    and it often runs faster because less is preprogrammed.
<br>
    If I try to do the same as above then we are going to have a very long
    conversation...
<br>
        <b>me</b>:  Hi Mata. I want to run a linear regression today
        <b>Mata</b>:  Hi Maarten. What is a "linear regression"?
        <b>me</b>:  Oh, it is a model where look at the relationship between
        variables
        <b>Mata</b>:  What is a variable?
        <b>me</b>:  Oh, it is a column in a matrix
        <b>Mata</b>:  I know what that is. Where shall I find that matrix? How shall
        we keep track of these “variables”? I love integers. Names, you say?
        Are those like strings? I have really long strings. Really, however,
        integers are better.
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide1.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide3.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide3.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                              <b> When to use which</b>
<br>
    Stata is better for . . .
        Parsing standard syntax
        Data management
        Scripting existing Stata commands (writing a .do file to do an
        analysis)
        Outputting (usually)
        Posting saved results
<br>
    Mata is better for . . .
        Parsing non-standard syntax (including files)
        Performing matrix operations
        Non-scripting applications
        Outputting (when complicated)
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide2.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide4.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide4.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                          <b> entering and leaving Mata</b>
<br>
    You can enter Mata by typing in Stata either <b>mata</b> or <b>mata:</b>
<br>
    You can leave Mata, and enter Stata again, by typing <b>end</b>
<br>
    <b>mata</b> will continue executing till it reaches <b>end</b> even if an error occured
        This is helpful when using Mata interactively to try things out
        When trying things out, errors are expected. It is convenient when
        those errors have not other consequences than an error message.
<br>
    <b>mata:</b> stops as soon as an error occured and drop you back into Stata.
        This is helpful when programming
 
        This makes it easier to find where the bug is
<br>
    Alternatively, you can pass a single line from Stata to Mata by typing
    <b>mata: something_Mata_understands</b>
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide3.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide5.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide5.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                               <b> Try it yourself</b>
<br>
    Enter Mata using <b>mata</b>
<br>
    Type <b>1 + 2</b>
<br>
    OK, so if we type an expression which has an answer, that answer is
    displayed on screen. In fact, that answer is not stored anywhere.
<br>
    Type <b>a = 1 + 2</b>
<br>
    Type <b>a</b>
<br>
    OK, so with an equal sign we can store answers
<br>
    Lets make an error: type <b>a = b</b>. We have not defined <b>b</b> yet, so what can
    Mata do other than return an error?
<br>
    Notice that the command prompt is still <b>:</b>, i.e. we are still in Mata
<br>
    Lets fix the error, type <b>b = "Hello"</b> and <b>a = b</b>
<br>
    Leave Mata by typing <b>end</b>
<br>
    We can try one-line execution of Mata commands from Stata: Type <b>mata: 1 +</b>
    <b>2</b>
<br>
    Lets try the same sequence of commands but with <b>mata:</b> instead of <b>mata</b>.
    You can copy the commands below in the .do file editor and run it:
<br>
<br>
<b>    clear mata</b>
<b>    mata:</b>
<b>    1 + 2</b>
<b>    a = 1 + 2</b>
<b>    a</b>
<b>    a = b</b>
<b>    b = "Hello"</b>
<b>    a = b</b>
<b>    end</b>
<br>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide4.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide6.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide6.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                     <b> things persist between Mata sessions</b>
<br>
    Things you create in Mata persist between Mata sessions untill you clear
    Mata or you close Stata
<br>
    That is why I added <b>clear mata</b> to the last exercise:
        The purpose was for the first line <b>a = b</b> to result in an error.
 
        However, in the previous exercise we successfuly created <b>b</b>, which
        will persist between sessions, so no error would occur.
        To make the desired error occur we needed to explicitly remove it
 
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: a = 1</b>
<br>
<b>: b = 2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. mata: a</b>
<b>  1</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: a + b</b>
<b>  3</b>
<br>
<b>: </b>
<b>: mata clear</b>
<br>
<b>: a</b>
                 &lt;istmt&gt;:  3499  a not found
(0 lines skipped)
-------------------------------------------------------------------------------
r(3499);
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide5.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide7.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide7.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                                  <b> variables</b>
<br>
    In Mata something is either a variable or a function
<br>
    Functions are like programs. We will discuss them later
<br>
    Anything that is not a function is a variable
<br>
    The purpose of a variable is to store information
<br>
    Variables differ depending on what is stored and how it is organized
<br>
    In Mata a variable can contain either:
        A real number (real)
        A complex number (complex)
        Text (string)
        The address where another object is stored in memory (pointer)
        A set of variables tied together under one name (struct)
        A set of variables and functions tied together under one name (class)
<br>
    This information can be organized as a:
        scalar
        rowvector
        colvector
        matrix
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide6.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide8.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide8.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- How is Mata different from Stata
-------------------------------------------------------------------------------
<br>
                              <b> creating variables</b>
<br>
    You create a variable with <b>=</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A = 1 , 2 \</b>
<b>&gt;     3 , 4</b>
<br>
<b>: </b>
<b>: A    </b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   2</b>  |
  2 |  <b>3   4</b>  |
    +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    Some functions return things that can be stored as a variable
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A = J(3,3,34)</b>
<br>
<b>: A</b>
[symmetric]
        1    2    3
    +----------------+
  1 |  <b>34          </b>  |
  2 |  <b>34   34     </b>  |
  3 |  <b>34   34   34</b>  |
    +----------------+
<br>
<b>: </b>
<b>: A = I(3,3)</b>
<br>
<b>: A</b>
[symmetric]
       1   2   3
    +-------------+
  1 |  <b>1        </b>  |
  2 |  <b>0   1    </b>  |
  3 |  <b>0   0   1</b>  |
    +-------------+
<br>
<b>: </b>
<b>: A = J(2,1,a)</b>
                 &lt;istmt&gt;:  3499  a not found
(1 line skipped)
-------------------------------------------------------------------------------
r(3499);
<br>
</pre>
<div class="txt"><pre>
    You can have matrices with 0 rows or columns or both. This can be helpful
    starting point when you want to successively add collumns or rows to a
    matrix.
<br>
        Note: Starting with complete matrix and successively changing the
        content of rows and columns is a lot quicker than changing the number
        of rows and columns of a matrix.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A = J(2,0,.)</b>
<br>
<b>: </b>
<b>: A = A , (2 \ 3)</b>
<br>
<b>: A</b>
<b>       </b>1
    +-----+
  1 |  <b>2</b>  |
  2 |  <b>3</b>  |
    +-----+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    You can chain assignments, which can be an easy way to initialize
    multiple variables
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: a = b = 2</b>
<br>
<b>: a</b>
<b>  2</b>
<br>
<b>: b</b>
<b>  2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    You can be more fancy with that
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: fraction = 2 /(sum=2+3)</b>
<br>
<b>: fraction</b>
<b>  .4</b>
<br>
<b>: sum</b>
<b>  5</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide7.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide9.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide9.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- matrix operations
-------------------------------------------------------------------------------
<br>
                                  <b> arithmatic</b>
<br>
    Matrix addition, subtraction, and multiplication work as you would expect
    with the <b>+</b>, <b>-</b>, and <b>*</b> operators:
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A = 1 , 2 \        </b>
<b>&gt;     3 , 2           </b>
<br>
<b>: </b>
<b>: b = 1     \</b>
<b>&gt;     2</b>
<br>
<b>: </b>
<b>: C = 2 , 4 \   </b>
<b>&gt;     1 , 3    </b>
<br>
<b>: </b>
<b>: A + C </b>
<b>       </b>1   2
    +---------+
  1 |  <b>3   6</b>  |
  2 |  <b>4   5</b>  |
    +---------+
<br>
<b>: </b>
<b>: A - C </b>
<b>       </b> 1    2
    +-----------+
  1 |  <b>-1   -2</b>  |
  2 |  <b> 2   -1</b>  |
    +-----------+
<br>
<b>: </b>
<b>: A * C </b>
<b>       </b> 1    2
    +-----------+
  1 |  <b> 4   10</b>  |
  2 |  <b> 8   18</b>  |
    +-----------+
<br>
<b>: </b>
<b>: A * b</b>
<b>       </b>1
    +-----+
  1 |  <b>5</b>  |
  2 |  <b>7</b>  |
    +-----+
<br>
<b>: end </b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    Multiplication of a matrix by a scalar works as expected
<br>
    By analogy, division by a scalar works just fine with the <b>/</b> operator
<br>
    The <b>/</b> operator does not work matrix division
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A*2</b>
<b>       </b>1   2
    +---------+
  1 |  <b>2   4</b>  |
  2 |  <b>6   4</b>  |
    +---------+
<br>
<b>: A/2</b>
<b>       </b>  1     2
    +-------------+
  1 |  <b> .5     1</b>  |
  2 |  <b>1.5     1</b>  |
    +-------------+
<br>
<b>: A / C</b>
                       /:  3204  matrix found where scalar required
                 &lt;istmt&gt;:     -  function returned error
(0 lines skipped)
-------------------------------------------------------------------------------
r(3204);
<br>
</pre>
<div class="txt"><pre>
    You can transpose a matrix with <b>'</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: b'</b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   2</b>  |
    +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide8.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide10.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide10.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- matrix operations
-------------------------------------------------------------------------------
<br>
                            <b> elementwise operations</b>
<br>
    Alternatively, you sometimes want to do something element by element
<br>
    For that you can add a colon in front of many operators
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A</b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   2</b>  |
  2 |  <b>3   2</b>  |
    +---------+
<br>
<b>: b</b>
<b>       </b>1
    +-----+
  1 |  <b>1</b>  |
  2 |  <b>2</b>  |
    +-----+
<br>
<b>: C</b>
<b>       </b>1   2
    +---------+
  1 |  <b>2   4</b>  |
  2 |  <b>1   3</b>  |
    +---------+
<br>
<b>: </b>
<b>: A:*C</b>
<b>       </b>1   2
    +---------+
  1 |  <b>2   8</b>  |
  2 |  <b>3   6</b>  |
    +---------+
<br>
<b>: A:*b</b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   2</b>  |
  2 |  <b>6   4</b>  |
    +---------+
<br>
<b>: A:*b'</b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   4</b>  |
  2 |  <b>3   4</b>  |
    +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
        What rules does <b>:*</b> apply to these matrices?
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide9.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide11.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide11.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- matrix operations
-------------------------------------------------------------------------------
<br>
                                 <b> Subscripting</b>
<br>
    We can get at cells in a matrix using <b>[]</b>:
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A</b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   2</b>  |
  2 |  <b>3   2</b>  |
    +---------+
<br>
<b>: b</b>
<b>       </b>1
    +-----+
  1 |  <b>1</b>  |
  2 |  <b>2</b>  |
    +-----+
<br>
<b>: </b>
<b>: A[2,1]</b>
<b>  3</b>
<br>
<b>: b[2]</b>
<b>  2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    We can also get at multiple cells
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: D = A, b</b>
<br>
<b>: D</b>
<b>       </b>1   2   3
    +-------------+
  1 |  <b>1   2   1</b>  |
  2 |  <b>3   2   2</b>  |
    +-------------+
<br>
<b>: D[2,.]</b>
<b>       </b>1   2   3
    +-------------+
  1 |  <b>3   2   2</b>  |
    +-------------+
<br>
<b>: D[.,2]</b>
<b>       </b>1
    +-----+
  1 |  <b>2</b>  |
  2 |  <b>2</b>  |
    +-----+
<br>
<b>: D[1,(2,3)]</b>
<b>       </b>1   2
    +---------+
  1 |  <b>2   1</b>  |
    +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    We can also specify the starting cell and the ending cell, and get the
    entire submatrix between those using <b>[||]</b>
<br>
    This can be faster
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: D[|1,2 \ 1,3|]</b>
<b>       </b>1   2
    +---------+
  1 |  <b>2   1</b>  |
    +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide10.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide12.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide12.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- matrix operations
-------------------------------------------------------------------------------
<br>
                                    <b> logic </b>
<br>
    Like in Stata 0 is false, and non-zero (including missing) is true
<br>
    Operators or functions that return true or false will return 0 for false
    and 1 for true
<br>
    The basic operators are:
        <b>==</b> for equals
        <b>!=</b> for not equals
        <b>&gt;</b> for larger than
        <b>&gt;=</b> for larger than or equal
        <b>&lt;</b> for less than
        <b>&lt;=</b> for than than or equal
        <b>!</b> for negation
        <b>&amp;</b> for and
        <b>|</b> for or
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide11.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide13.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide13.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- matrix operations
-------------------------------------------------------------------------------
<br>
                              <b> elementwise logic</b>
<br>
    You can also use the elementwise colon operator for logic
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A:==2</b>
<b>       </b>1   2
    +---------+
  1 |  <b>0   1</b>  |
  2 |  <b>0   1</b>  |
    +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
        You can add the elements of a matrix with the sum() function.  So we
        can count the number of 2s in the matrix <b>A</b>.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: sum(A:==2)</b>
<b>  2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    Since 0 is false and non-zero is true, we can use the previous answer to
    test whether 2 occurs in matrix <b>A</b>.
<br>
    Better (quicker and less memory used) would be to use the <b>any()</b> function:
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata: any(A:==2)</b>
<b>  1</b>
<br>
</pre>
<div class="txt"><pre>
    Even better would be to use <b>anyof()</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata: anyof(A,2)</b>
<b>  1</b>
<br>
</pre>
<div class="txt"><pre>
    Similarly you can use <b>all()</b> and <b>allof()</b> to check if <i>all</i> elements are true
    or equal to some value.
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide12.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide14.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide14.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- precision
-------------------------------------------------------------------------------
<br>
                            <b> binary versus decimal</b>
<br>
    There is a limit on how precise numbers are stored on computers
<br>
    If a computer stored numbers in decimal format we would not be surprised
    that we could not store the number 1/3 exactly; we would have to stop
    storing 3s otherwise we would need an infinite amount of memory to store
    one number.
<br>
    A computer however stores numbers in binary format. In binary some
    numbers we would not consider problematic, are actualy like 1/3. The most
    common example is 0.1.
<br>
    So a lot of numbers we think are perfectly "normal" are in a computer
    actually rounded versions of that number.
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide13.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide15.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide15.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- precision
-------------------------------------------------------------------------------
<br>
                            <b> how a number is stored</b>
<br>
    So how are numbers stored?
<br>
    We could say that we store a number up to 6 digits after the decimal
    point (ignoring that they are actually stored in binary)
<br>
    This is problematic
<br>
        We would store the number 1,000,000 with 13 significant digits
<br>
        While we would store the number 0.0001 with only 3 significant digits
<br>
    Instead a number is stored in three parts: the sign and two numbers, lets
    call them a and b
<br>
    If we would store the number in decimal format the number stored would
    then be sign * a * 10^b
<br>
    So if we decided on 6 significant digits we would store the number
    1,000,000 as +1*1.00000*10^6 and the number 0.0001 as +1*1.00000*10^-4
<br>
    In real computers both a and b are binary numbers and we don't use 10^b,
    but 2^b
<br>
    In Mata all real numbers are stored in "double precision":
        A number is stored using 8 bytes, i.e. 64 bits
        1 bit is used for the sign
        11 bits are used for the exponent (b)
        The remaining 52 bits are used for the fractional part (a)
        27 of the possible configurations of bits are reserved for missing
        values (., .a, .b, .., .z)
        2 possible configurations of bits are reserved for 0 (+0 and -0)
<br>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide14.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide16.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide16.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- precision
-------------------------------------------------------------------------------
<br>
                   <b> rounding errors: adding and subtracting</b>
<br>
    This way of storing number allows us to reliably store number within a
    very large range.
<br>
    It has some quirks, for example adding numbers that differ by a large
    order of magnitude can lead to quite large rounding errors.
<br>
    We want to add 1,000,000 and 0.0001
<br>
        Then we are adding +1*1,00000*10^6 and +1*1.00000*10^-4
<br>
        In order to add them we would need to the exponent the same:
<br>
        We would change +1*1.00000*10^-4 to +1*0.00000000001*10^6
<br>
        However, we only stored 6 digits, so 0.00000000001 gets rounded to 0
<br>
    A common computations where this could be a problem are:
<br>
        Computing a sum of values in a large matrix
<br>
        1 - probability
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide15.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide17.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide17.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- moving data between Stata and Mata
-------------------------------------------------------------------------------
<br>
                       <b> reading data from Stata in Mata</b>
<br>
    You can store parts of a Stata dataset as a matrix using <b>st_data()</b>.
<br>
    In its simplest form it accepts two arguments
        The first argument specifies the rows
        The second argument specifies the columns
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: y = st_data(.,"foreign rep78")</b>
<br>
<b>: y</b>
<b>        </b>1   2
     +---------+
   1 |  <b>0   3</b>  |
   2 |  <b>0   3</b>  |
   3 |  <b>0   .</b>  |
   4 |  <b>0   3</b>  |
   5 |  <b>0   4</b>  |
   6 |  <b>0   3</b>  |
   7 |  <b>0   .</b>  |
   8 |  <b>0   3</b>  |
   9 |  <b>0   3</b>  |
  10 |  <b>0   3</b>  |
  11 |  <b>0   3</b>  |
  12 |  <b>0   2</b>  |
  13 |  <b>0   3</b>  |
  14 |  <b>0   3</b>  |
  15 |  <b>0   4</b>  |
  16 |  <b>0   3</b>  |
  17 |  <b>0   2</b>  |
  18 |  <b>0   2</b>  |
  19 |  <b>0   3</b>  |
  20 |  <b>0   5</b>  |
  21 |  <b>0   2</b>  |
  22 |  <b>0   2</b>  |
  23 |  <b>0   2</b>  |
  24 |  <b>0   4</b>  |
  25 |  <b>0   3</b>  |
  26 |  <b>0   3</b>  |
  27 |  <b>0   3</b>  |
  28 |  <b>0   3</b>  |
  29 |  <b>0   4</b>  |
  30 |  <b>0   4</b>  |
  31 |  <b>0   3</b>  |
  32 |  <b>0   3</b>  |
  33 |  <b>0   4</b>  |
  34 |  <b>0   3</b>  |
  35 |  <b>0   4</b>  |
  36 |  <b>0   3</b>  |
  37 |  <b>0   3</b>  |
  38 |  <b>0   4</b>  |
  39 |  <b>0   3</b>  |
  40 |  <b>0   1</b>  |
  41 |  <b>0   3</b>  |
  42 |  <b>0   3</b>  |
  43 |  <b>0   5</b>  |
  44 |  <b>0   3</b>  |
  45 |  <b>0   .</b>  |
  46 |  <b>0   2</b>  |
  47 |  <b>0   4</b>  |
  48 |  <b>0   1</b>  |
  49 |  <b>0   3</b>  |
  50 |  <b>0   3</b>  |
  51 |  <b>0   .</b>  |
  52 |  <b>0   2</b>  |
  53 |  <b>1   5</b>  |
  54 |  <b>1   3</b>  |
  55 |  <b>1   4</b>  |
  56 |  <b>1   4</b>  |
  57 |  <b>1   5</b>  |
  58 |  <b>1   4</b>  |
  59 |  <b>1   4</b>  |
  60 |  <b>1   3</b>  |
  61 |  <b>1   5</b>  |
  62 |  <b>1   4</b>  |
  63 |  <b>1   4</b>  |
  64 |  <b>1   .</b>  |
  65 |  <b>1   3</b>  |
  66 |  <b>1   5</b>  |
  67 |  <b>1   5</b>  |
  68 |  <b>1   5</b>  |
  69 |  <b>1   5</b>  |
  70 |  <b>1   4</b>  |
  71 |  <b>1   5</b>  |
  72 |  <b>1   4</b>  |
  73 |  <b>1   4</b>  |
  74 |  <b>1   5</b>  |
     +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    Notice that we have missing values, which we may want to ignore
<br>
    One posibility is to set a third argument equal to 0. This will ignore
    all observations with at least one missing value on one of the specified
    variables.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata: </b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: y = st_data(.,"foreign rep78", 0)</b>
<br>
<b>: y</b>
<b>        </b>1   2
     +---------+
   1 |  <b>0   3</b>  |
   2 |  <b>0   3</b>  |
   3 |  <b>0   3</b>  |
   4 |  <b>0   4</b>  |
   5 |  <b>0   3</b>  |
   6 |  <b>0   3</b>  |
   7 |  <b>0   3</b>  |
   8 |  <b>0   3</b>  |
   9 |  <b>0   3</b>  |
  10 |  <b>0   2</b>  |
  11 |  <b>0   3</b>  |
  12 |  <b>0   3</b>  |
  13 |  <b>0   4</b>  |
  14 |  <b>0   3</b>  |
  15 |  <b>0   2</b>  |
  16 |  <b>0   2</b>  |
  17 |  <b>0   3</b>  |
  18 |  <b>0   5</b>  |
  19 |  <b>0   2</b>  |
  20 |  <b>0   2</b>  |
  21 |  <b>0   2</b>  |
  22 |  <b>0   4</b>  |
  23 |  <b>0   3</b>  |
  24 |  <b>0   3</b>  |
  25 |  <b>0   3</b>  |
  26 |  <b>0   3</b>  |
  27 |  <b>0   4</b>  |
  28 |  <b>0   4</b>  |
  29 |  <b>0   3</b>  |
  30 |  <b>0   3</b>  |
  31 |  <b>0   4</b>  |
  32 |  <b>0   3</b>  |
  33 |  <b>0   4</b>  |
  34 |  <b>0   3</b>  |
  35 |  <b>0   3</b>  |
  36 |  <b>0   4</b>  |
  37 |  <b>0   3</b>  |
  38 |  <b>0   1</b>  |
  39 |  <b>0   3</b>  |
  40 |  <b>0   3</b>  |
  41 |  <b>0   5</b>  |
  42 |  <b>0   3</b>  |
  43 |  <b>0   2</b>  |
  44 |  <b>0   4</b>  |
  45 |  <b>0   1</b>  |
  46 |  <b>0   3</b>  |
  47 |  <b>0   3</b>  |
  48 |  <b>0   2</b>  |
  49 |  <b>1   5</b>  |
  50 |  <b>1   3</b>  |
  51 |  <b>1   4</b>  |
  52 |  <b>1   4</b>  |
  53 |  <b>1   5</b>  |
  54 |  <b>1   4</b>  |
  55 |  <b>1   4</b>  |
  56 |  <b>1   3</b>  |
  57 |  <b>1   5</b>  |
  58 |  <b>1   4</b>  |
  59 |  <b>1   4</b>  |
  60 |  <b>1   3</b>  |
  61 |  <b>1   5</b>  |
  62 |  <b>1   5</b>  |
  63 |  <b>1   5</b>  |
  64 |  <b>1   5</b>  |
  65 |  <b>1   4</b>  |
  66 |  <b>1   5</b>  |
  67 |  <b>1   4</b>  |
  68 |  <b>1   4</b>  |
  69 |  <b>1   5</b>  |
     +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    Alternatively, that third argument can be a variable
<br>
    non-zero values indicate that that observation is to be included, while a
    value of zero means that that observation is to be ignored
<br>
    In programming, this is the most common way to do this
<br>
</pre>
</div><pre class="output">
<br>
<b>. gen byte touse = !missing(foreign, rep78)</b>
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: y = st_data(.,"foreign rep78", "touse")</b>
<br>
<b>: y</b>
<b>        </b>1   2
     +---------+
   1 |  <b>0   3</b>  |
   2 |  <b>0   3</b>  |
   3 |  <b>0   3</b>  |
   4 |  <b>0   4</b>  |
   5 |  <b>0   3</b>  |
   6 |  <b>0   3</b>  |
   7 |  <b>0   3</b>  |
   8 |  <b>0   3</b>  |
   9 |  <b>0   3</b>  |
  10 |  <b>0   2</b>  |
  11 |  <b>0   3</b>  |
  12 |  <b>0   3</b>  |
  13 |  <b>0   4</b>  |
  14 |  <b>0   3</b>  |
  15 |  <b>0   2</b>  |
  16 |  <b>0   2</b>  |
  17 |  <b>0   3</b>  |
  18 |  <b>0   5</b>  |
  19 |  <b>0   2</b>  |
  20 |  <b>0   2</b>  |
  21 |  <b>0   2</b>  |
  22 |  <b>0   4</b>  |
  23 |  <b>0   3</b>  |
  24 |  <b>0   3</b>  |
  25 |  <b>0   3</b>  |
  26 |  <b>0   3</b>  |
  27 |  <b>0   4</b>  |
  28 |  <b>0   4</b>  |
  29 |  <b>0   3</b>  |
  30 |  <b>0   3</b>  |
  31 |  <b>0   4</b>  |
  32 |  <b>0   3</b>  |
  33 |  <b>0   4</b>  |
  34 |  <b>0   3</b>  |
  35 |  <b>0   3</b>  |
  36 |  <b>0   4</b>  |
  37 |  <b>0   3</b>  |
  38 |  <b>0   1</b>  |
  39 |  <b>0   3</b>  |
  40 |  <b>0   3</b>  |
  41 |  <b>0   5</b>  |
  42 |  <b>0   3</b>  |
  43 |  <b>0   2</b>  |
  44 |  <b>0   4</b>  |
  45 |  <b>0   1</b>  |
  46 |  <b>0   3</b>  |
  47 |  <b>0   3</b>  |
  48 |  <b>0   2</b>  |
  49 |  <b>1   5</b>  |
  50 |  <b>1   3</b>  |
  51 |  <b>1   4</b>  |
  52 |  <b>1   4</b>  |
  53 |  <b>1   5</b>  |
  54 |  <b>1   4</b>  |
  55 |  <b>1   4</b>  |
  56 |  <b>1   3</b>  |
  57 |  <b>1   5</b>  |
  58 |  <b>1   4</b>  |
  59 |  <b>1   4</b>  |
  60 |  <b>1   3</b>  |
  61 |  <b>1   5</b>  |
  62 |  <b>1   5</b>  |
  63 |  <b>1   5</b>  |
  64 |  <b>1   5</b>  |
  65 |  <b>1   4</b>  |
  66 |  <b>1   5</b>  |
  67 |  <b>1   4</b>  |
  68 |  <b>1   4</b>  |
  69 |  <b>1   5</b>  |
     +---------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide16.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide18.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide18.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- moving data between Stata and Mata
-------------------------------------------------------------------------------
<br>
                       <b> storing data from Mata in Stata</b>
<br>
    We can store a matrix in Mata as (a) variable(s) using <b>st_store()</b>
<br>
    This will replace existing variables
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. mata: </b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: x = st_data(.,"foreign")</b>
<br>
<b>: x = x:+10</b>
<br>
<b>: st_store(.,"foreign",x)</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. tab foreign</b>
<br>
<b> </b>Car origin |      Freq.     Percent        Cum.
------------+-----------------------------------
         10 |<b>         52       70.27       70.27</b>
         11 |<b>         22       29.73      100.00</b>
------------+-----------------------------------
      Total |<b>         74      100.00</b>
<br>
</pre>
<div class="txt"><pre>
    If we want to store our matrix as a new variable, then we first have to
    create that variable with <b>st_addvar</b>, and than replace its content with
    <b>st_store()</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: x = st_data(.,"foreign")</b>
<br>
<b>: x = x :+ 10</b>
<br>
<b>: idx = st_addvar("byte", "x")</b>
<br>
<b>: st_store(.,idx, x)</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. tab foreign x</b>
<br>
<b>           </b>|           x
Car origin |        10         11 |     Total
-----------+----------------------+----------
  Domestic |<b>        52          0 </b>|<b>        52 </b>
   Foreign |<b>         0         22 </b>|<b>        22 </b>
-----------+----------------------+----------
     Total |<b>        52         22 </b>|<b>        74 </b>
<br>
</pre>
<div class="txt"><pre>
    We can control which observations gets a value by using a selection
    variable
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. gen touse = !missing(foreign, rep78)</b>
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: x = st_data(.,"foreign", "touse")</b>
<br>
<b>: x = x :+ 10</b>
<br>
<b>: idx = st_addvar("byte", "x")</b>
<br>
<b>: st_store(.,idx, "touse", x)</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. tab foreign x, missing</b>
<br>
<b>           </b>|                x
Car origin |        10         11          . |     Total
-----------+---------------------------------+----------
  Domestic |<b>        48          0          4 </b>|<b>        52 </b>
   Foreign |<b>         0         21          1 </b>|<b>        22 </b>
-----------+---------------------------------+----------
     Total |<b>        48         21          5 </b>|<b>        74 </b>
<br>
<b>. tab x touse, missing</b>
<br>
<b>           </b>|         touse
         x |         0          1 |     Total
-----------+----------------------+----------
        10 |<b>         0         48 </b>|<b>        48 </b>
        11 |<b>         0         21 </b>|<b>        21 </b>
         . |<b>         5          0 </b>|<b>         5 </b>
-----------+----------------------+----------
     Total |<b>         5         69 </b>|<b>        74 </b>
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide17.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide19.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide19.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- moving data between Stata and Mata
-------------------------------------------------------------------------------
<br>
                              <b> views and subviews</b>
<br>
    If we use <b>st_data</b> to load data into Mata, we are making a copy of that
    datast meaning we use potentially a lot of memory.
<br>
    Alternatively, we can make a "view" of the data which directly "sees" the
    Stata data rather than make a copy of it.
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. gen byte touse = !missing(foreign, rep78, price)</b>
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: Data = .</b>
<br>
<b>: st_view(Data, ., "foreign rep78 price", "touse")</b>
<br>
<b>: Data[1..10,.]</b>
<b>        </b>    1       2       3
     +-------------------------+
   1 |  <b>    0       3    4099</b>  |
   2 |  <b>    0       3    4749</b>  |
   3 |  <b>    0       3    4816</b>  |
   4 |  <b>    0       4    7827</b>  |
   5 |  <b>    0       3    5788</b>  |
   6 |  <b>    0       3    5189</b>  |
   7 |  <b>    0       3   10372</b>  |
   8 |  <b>    0       3    4082</b>  |
   9 |  <b>    0       3   11385</b>  |
  10 |  <b>    0       2   14500</b>  |
     +-------------------------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    Since a view directly sees the Stata data, we change that data when we
    change the view
<br>
</pre>
</div><pre class="output">
<br>
<b>. list foreign in 1/5</b>
<br>
     +----------+
     | <b> foreign </b>|
     |----------|
  1. | <b>Domestic </b>|
  2. | <b>Domestic </b>|
  3. | <b>Domestic </b>|
  4. | <b>Domestic </b>|
  5. | <b>Domestic </b>|
     +----------+
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: Data[1,1] = 5</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. list foreign in 1/5</b>
<br>
     +----------+
     | <b> foreign </b>|
     |----------|
  1. | <b>       5 </b>|
  2. | <b>Domestic </b>|
  3. | <b>Domestic </b>|
  4. | <b>Domestic </b>|
  5. | <b>Domestic </b>|
     +----------+
<br>
</pre>
<div class="txt"><pre>
    Often we want to get different parts of the data into Mata as different
    matrices
<br>
    For example, we may want a dependent variable in a vector <b>y</b>, and the
    independent variables in a matrix <b>X</b>
<br>
    We need to make sure that all matices use the same observations
<br>
    The best way to do that is to use a common selection variable
<br>
    Alternatively, we can make a main view of all variables we need, and make
    subviews from that main view using <b>subview()</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: Data = y = X = .</b>
<br>
<b>: st_view(Data,.,"foreign rep78 price",0)</b>
<br>
<b>: st_subview(y,Data,.,1)</b>
<br>
<b>: st_subview(X,Data,.,(2\.))</b>
<br>
<b>: Data[1..5,.]</b>
<b>       </b>   1      2      3
    +----------------------+
  1 |  <b>   0      3   4099</b>  |
  2 |  <b>   0      3   4749</b>  |
  3 |  <b>   0      3   4816</b>  |
  4 |  <b>   0      4   7827</b>  |
  5 |  <b>   0      3   5788</b>  |
    +----------------------+
<br>
<b>: y[1..5,.]</b>
<b>       </b>1
    +-----+
  1 |  <b>0</b>  |
  2 |  <b>0</b>  |
  3 |  <b>0</b>  |
  4 |  <b>0</b>  |
  5 |  <b>0</b>  |
    +-----+
<br>
<b>: X[1..5,.]</b>
<b>       </b>   1      2
    +---------------+
  1 |  <b>   3   4099</b>  |
  2 |  <b>   3   4749</b>  |
  3 |  <b>   3   4816</b>  |
  4 |  <b>   4   7827</b>  |
  5 |  <b>   3   5788</b>  |
    +---------------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide18.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide20.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide20.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- moving data between Stata and Mata
-------------------------------------------------------------------------------
<br>
              <b> reading and writing matrices and macros from Stata</b>
<br>
    Stata also has matrices, and we may want to load those in Stata. We do
    that with the <b>st_matrix()</b> function.
<br>
    For example, <b>regress</b> leaves the coefficients as the rowvector e(b)
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. reg wage i.union i.race i.south grade ttl_exp</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,876</b>
-------------+----------------------------------   F(6, 1869)      = <b>   133.68</b>
       Model | <b>  9789.5268         6   1631.5878   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22811.9477     1,869  12.2054295   </b>R-squared       =<b>    0.3003</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2980</b>
       Total | <b> 32601.4745     1,875  17.3874531   </b>Root MSE        =   <b> 3.4936</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       union |
      Union  |<b>   .8762805   .1921366     4.56   0.000     .4994557    1.253105</b>
             |
        race |
      Black  |<b>  -.4220536   .1938443    -2.18   0.030    -.8022276   -.0418796</b>
      Other  |<b>   .7718287   .7206785     1.07   0.284    -.6415906    2.185248</b>
             |
       south |
      South  |<b>  -.8955855   .1726014    -5.19   0.000    -1.234097   -.5570737</b>
       grade |<b>   .5798155   .0328168    17.67   0.000      .515454     .644177</b>
     ttl_exp |<b>   .2681669   .0178573    15.02   0.000     .2331446    .3031892</b>
       _cons |<b>  -3.233793   .4705745    -6.87   0.000    -4.156699   -2.310886</b>
------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: b = st_matrix("e(b)")</b>
<br>
<b>: b</b>
<b>       </b>           1              2              3              4
    +-------------------------------------------------------------
  1 |  <b>           0    .8762805149              0   -.4220535843</b>
    +-------------------------------------------------------------
                  5              6              7              8
     -------------------------------------------------------------
  1    <b> .7718286975              0   -.8955855048    .5798155063</b>
     -------------------------------------------------------------
                  9             10
     -------------------------------+
  1    <b>  .268166922   -3.233792755</b>  |
     -------------------------------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    We can also use <b>st_matrix()</b> to copy matrices from Mata to Stata
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: X = 1,2 \ </b>
<b>&gt;     3,4</b>
<br>
<b>: st_matrix("X",X)    </b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. matlist X</b>
<br>
             |        c1         c2 
-------------+----------------------
          r1 | <b>        1</b>  <b>        2</b> 
          r2 | <b>        3</b>  <b>        4</b> 
<br>
</pre>
<div class="txt"><pre>
    We can also read the content of <b>macros</b> and <b>scalars</b> from Stata into Mata
    using <b>st_local()</b> and <b> st_scalar()</b>
<br>
    we can use the same functions to write to Stata
<br>
    There are some <a href="#slide21.smcl">&gt;&gt; arcana of macros and scalars in Stata</a>to consider
<br>
</pre>
</div><pre class="output">
<br>
<b>. tempname realnumber</b>
<br>
<b>. local nirv "here we are now, entertain us"</b>
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: st_local("nirv")</b>
<b>  here we are now, entertain us</b>
<br>
<b>: st_local("greetings", "Hello")</b>
<br>
<b>: st_local("number", strofreal(42))</b>
<br>
<b>: st_numscalar(st_local("realnumber"), 42)</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. di "`greetings'"</b>
<b>Hello</b>
<br>
<b>. di `number'</b>
<b>42</b>
<br>
<b>. di `realnumber'</b>
<b>42</b>
<br>
</pre>
<div class="txt"><pre>
    We have already seen that we can access returned matrices using
    <b>st_matrix()</b>
<br>
    Returned string scalars can be accessed using <b>st_global()</b>
<br>
    Returned numeric scalars can be accessed using <b>st_numscalar()</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. ereturn list</b>
<br>
scalars:
                  e(N) =  <b>1876</b>
<b>               </b>e(df_m) =  <b>6</b>
<b>               </b>e(df_r) =  <b>1869</b>
<b>                  </b>e(F) =  <b>133.6772130604341</b>
<b>                 </b>e(r2) =  <b>.3002786511498445</b>
<b>               </b>e(rmse) =  <b>3.493626984318627</b>
<b>                </b>e(mss) =  <b>9789.526803052533</b>
<b>                </b>e(rss) =  <b>22811.94774589027</b>
<b>               </b>e(r2_a) =  <b>.298032354684836</b>
<b>                 </b>e(ll) =  <b>-5005.186420890172</b>
<b>               </b>e(ll_0) =  <b>-5340.120985183983</b>
<b>               </b>e(rank) =  <b>7</b>
<br>
macros:
            e(cmdline) : "<b>regress wage i.union i.race i.south grade ttl_exp</b>"
              e(title) : "<b>Linear regression</b>"
          e(marginsok) : "<b>XB default</b>"
                e(vce) : "<b>ols</b>"
             e(depvar) : "<b>wage</b>"
                e(cmd) : "<b>regress</b>"
         e(properties) : "<b>b V</b>"
            e(predict) : "<b>regres_p</b>"
              e(model) : "<b>ols</b>"
          e(estat_cmd) : "<b>regress_estat</b>"
<br>
matrices:
                  e(b) : <b> 1 x 10</b>
<b>                  </b>e(V) : <b> 10 x 10</b>
<br>
functions:
             e(sample)   
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: st_global("e(title)")</b>
<b>  Linear regression</b>
<br>
<b>: st_numscalar("e(N)")</b>
<b>  1876</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide19.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide22.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide22.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                     <b> linear regression: getting variables</b>
<br>
    I am going to implement a linear regression in Mata in steps
<br>
    You are going to implement a IV regression with a two stage least square
    estimator using similar steps
<br>
    Data: nlsw88
<br>
    <b>y</b> = wage
    <b>X</b> = grade union ttl_exp tenure south
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. gen byte touse = !missing(wage, grade, union, ttl_exp, tenure, south)</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: X=y=.</b>
<br>
<b>: st_view(X,.,"grade union ttl_exp tenure south", "touse")</b>
<br>
<b>: st_view(y,.,"wage", "touse")</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide20.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide23.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide23.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                               <b> Try it yourself</b>
<br>
    We are going to implement a IV regression via two stage least squares
<br>
    The data is hsng2
    The dependent variable <b>y</b> is rent
    The endogenous variable <b>Y</b> is hsngval
    The instruments <b>X2</b> are faminc reg2 reg3 and reg4
    The other exogenous variables <b>X1</b> is pcturban
<br>
    We need to load three matrices:
        <b>y</b>
        <b>X</b> = <b>Y</b>, <b>X1</b>, <b>cons</b>
        <b>Z</b> = <b>X1</b>, <b>X2</b>, <b>cons</b>
<br>
    Open the dataset using <b>webuse</b>, create a new variable cons containing 1,
    and load the three matrices in Mata
<br>
</pre>
<pre><a href="#app0">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide22.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide24.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide24.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                             <b> Parameter estimates</b>
<br>
    The formula for the parameter estimates <b>b</b> in a linear regression is: <b>b</b> =
    <b>X</b>'<b>X</b>^-1<b>X</b>'<b>y</b>
<br>
    Notice that I did not add the constant here. That is because I (mostly)
    don't need to as <b>cross()</b> will do most of the computions and allows you to
    add the constant on the fly
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. gen byte touse = !missing(wage, grade, union, ttl_exp, tenure, south)</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: X=y=.</b>
<br>
<b>: st_view(X,.,"grade union ttl_exp tenure south", "touse")</b>
<br>
<b>: st_view(y,.,"wage", "touse")</b>
<br>
<b>: XX = cross(X,1, X,1)</b>
<br>
<b>: Xy = cross(X,1, y,0)</b>
<br>
<b>: b = invsym(XX)*Xy</b>
<br>
<b>: b</b>
<b>       </b>           1
    +----------------+
  1 |  <b> .5910388365</b>  |
  2 |  <b> .7654532103</b>  |
  3 |  <b> .2348584673</b>  |
  4 |  <b> .0412963548</b>  |
  5 |  <b>-.9976962817</b>  |
  6 |  <b>-3.245932113</b>  |
    +----------------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. reg wage grade union ttl_exp tenure south</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,866</b>
-------------+----------------------------------   F(5, 1860)      = <b>   158.02</b>
       Model | <b> 9668.81879         5  1933.76376   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22761.2079     1,860  12.2372085   </b>R-squared       =<b>    0.2981</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2963</b>
       Total | <b> 32430.0267     1,865  17.3887542   </b>Root MSE        =   <b> 3.4982</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide23.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide25.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide25.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    The formulas for the parameter estimates of 2sls model are:
<br>
    <b>b</b> = (<b>X</b>'<b>MX</b>)^-1<b>X</b>'<b>My</b>
    <b>M</b> = <b>Z</b>(<b>Z</b>'<b>Z</b>)^-1<b>Z</b>'
<br>
    They don't lend themselves so readily for <b>cross</b>, which is why we added
    the constants
<br>
    Continue working in your do file and compute <b>M</b> and <b>b</b>
<br>
    Check your results agains <b>ivregress 2sls rent pcturban (hsngval = faminc</b>
    <b>i.region), small</b>
<br>
</pre>
<pre><a href="#app1">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide24.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide26.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide26.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                        <b> The variance covariance matrix</b>
<br>
    <b>Var(b)</b> = s2*<b>X</b>'<b>X</b>^-1
    s2 = ess/(N-k)
    ess = (<b>y</b>-<b>Xb</b>)'(<b>y</b>-<b>Xb</b>)
    N = rows(<b>X</b>)
    k = cols(<b>X</b>) + 1 (the +1 for the constant)
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. gen byte touse = !missing(wage, grade, union, ttl_exp, tenure, south)</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: X=y=.</b>
<br>
<b>: st_view(X,.,"grade union ttl_exp tenure south", "touse")</b>
<br>
<b>: st_view(y,.,"wage", "touse")</b>
<br>
<b>: XX = cross(X,1, X,1)</b>
<br>
<b>: Xy = cross(X,1, y,0)</b>
<br>
<b>: b = invsym(XX)*Xy</b>
<br>
<b>: </b>
<b>: N = rows(X)</b>
<br>
<b>: k = cols(X) + 1</b>
<br>
<b>: cons = J(N,1,1)</b>
<br>
<b>: res = y - (X,cons)*b</b>
<br>
<b>: ess = cross(res,res)</b>
<br>
<b>: s2 = ess/(N-k)</b>
<br>
<b>: Var = s2*invsym(XX)</b>
<br>
<b>: sqrt(diagonal(Var))</b>
<b>       </b>          1
    +---------------+
  1 |  <b>.0324833365</b>  |
  2 |  <b>.1922649311</b>  |
  3 |  <b>.0219677852</b>  |
  4 |  <b>.0178784551</b>  |
  5 |  <b>.1663996582</b>  |
  6 |  <b>.4680530328</b>  |
    +---------------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. reg wage grade union ttl_exp tenure south</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,866</b>
-------------+----------------------------------   F(5, 1860)      = <b>   158.02</b>
       Model | <b> 9668.81879         5  1933.76376   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22761.2079     1,860  12.2372085   </b>R-squared       =<b>    0.2981</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2963</b>
       Total | <b> 32430.0267     1,865  17.3887542   </b>Root MSE        =   <b> 3.4982</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide25.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide27.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide27.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                               <b> Try it yourself</b>
<br>
    The formulas for the variance covariance matrix in the 2sls estimator
    are:
<br>
    <b>Var(b)</b> = s2*<b>X</b>'<b>MX</b>^-1
    s2 = ess/(N-k)
    ess = (<b>y</b>-<b>Xb</b>)'(<b>y</b>-<b>Xb</b>)
    N = rows(<b>X</b>)
    k = cols(<b>X</b>) (not +1: constant is already in X)
<br>
    Expand your do-file to create the variance covariance matrix
<br>
</pre>
<pre><a href="#app2">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide26.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide28.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide28.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                   <b> Export and display the results in Stata</b>
<br>
    We can use <b>ereturn</b> in Stata to display our results in the standard way
    Stata users expect from an estimation commands
<br>
    We first need to export our results from Mata to Stata and than use
    <b>ereturn</b>
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. gen byte touse = !missing(wage, grade, union, ttl_exp, tenure, south)</b>
<br>
<b>. </b>
<b>. tempname b V</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: X=y=.</b>
<br>
<b>: st_view(X,.,"grade union ttl_exp tenure south", "touse")</b>
<br>
<b>: st_view(y,.,"wage", "touse")</b>
<br>
<b>: XX = cross(X,1, X,1)</b>
<br>
<b>: Xy = cross(X,1, y,0)</b>
<br>
<b>: b = invsym(XX)*Xy</b>
<br>
<b>: </b>
<b>: N = rows(X)</b>
<br>
<b>: k = cols(X) + 1</b>
<br>
<b>: cons = J(N,1,1)</b>
<br>
<b>: res = y - (X,cons)*b</b>
<br>
<b>: ess = cross(res,res)</b>
<br>
<b>: s2 = ess/(N-k)</b>
<br>
<b>: Var = s2*invsym(XX)</b>
<br>
<b>: </b>
<b>: st_matrix(st_local("b"), b')</b>
<br>
<b>: st_matrix(st_local("V"), Var)</b>
<br>
<b>: st_local("df_r", strofreal(N-k))</b>
<br>
<b>: st_local("N", strofreal(N))</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. local xnames `""grade" "union" "ttl_exp" "tenure" "south" "_cons""'</b>
<br>
<b>. matrix colnames `b' = `xnames'</b>
<br>
<b>. matrix colnames `V' = `xnames'</b>
<br>
<b>. matrix rownames `V' = `xnames'</b>
<br>
<b>. ereturn post `b' `V', dof(`df_r') obs(`N') esample(touse)</b>
<br>
<b>. ereturn display</b>
------------------------------------------------------------------------------
             | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. reg wage grade union ttl_exp tenure south</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,866</b>
-------------+----------------------------------   F(5, 1860)      = <b>   158.02</b>
       Model | <b> 9668.81879         5  1933.76376   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22761.2079     1,860  12.2372085   </b>R-squared       =<b>    0.2981</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2963</b>
       Total | <b> 32430.0267     1,865  17.3887542   </b>Root MSE        =   <b> 3.4982</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide27.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide29.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide29.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Basics of mata</b> -- Application: linear regression and instrumental variable
regression
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Use the same tricks to display the results from your 2sls estimator
<br>
</pre>
<pre><a href="#app3">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide28.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide30.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide30.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                  <b> functions</b>
<br>
    In said before that in Mata something is either a variable or a function,
    and we have talked about variables
<br>
    A function is a program, for example:
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict off</b>
<br>
<b>: </b>
<b>: real scalar my_median(string scalar varn)</b>
<b>&gt; {</b>
<b>&gt;     x = st_data(.,varn, 0)</b>
<b>&gt;     _sort(x,1)</b>
<b>&gt;     index = ceil(rows(x)/2)</b>
<b>&gt;     return(x[index])</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. mata: my_median("tenure")</b>
<b>  3.833333254</b>
<br>
<b>. sum tenure, detail</b>
<br>
<b>                     </b>Job tenure (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>        0              0</b>
 5%    <b>      .25              0</b>
10%    <b> .5833333              0       </b>Obs         <b>      2,231</b>
25%    <b> 1.583333              0       </b>Sum of wgt. <b>      2,231</b>
<br>
50%    <b> 3.833333                      </b>Mean          <b>  5.97785</b>
<b>                        </b>Largest       Std. dev.     <b> 5.510331</b>
75%    <b> 9.333333           22.5</b>
90%    <b>    14.75       23.08333       </b>Variance      <b> 30.36375</b>
95%    <b> 17.41667          24.75       </b>Skewness      <b> 1.044433</b>
99%    <b> 20.83333       25.91667       </b>Kurtosis      <b> 3.166485</b>
<br>
</pre>
<div class="txt"><pre>
    So we created a function called <b>my_median()</b>
<br>
    But first we need to specify what kind of thing this function is going to
    return, in our case a real scalar (a single number)
<br>
    Within the parantheses we specify what our function expects as arguments
        First what kind of thing it is, in our case a string scalar
        Second the name it will have inside our function, in our case <i>varn</i>
<br>
    Whithin the braces we put what the function does, in our case:
        We first loaded the data
        Sorted that variable
        Computed at what point the middle is
        Returned the middle value
<br>
    It is a start, but there are still various problems with this function
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide29.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide31.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide31.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Create a similar function <b>my_mean()</b> which returns the mean (ignoring the
    fact that Mata already has a function <b>mean()</b>)
<br>
</pre>
<pre><a href="#app4">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide30.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide32.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide32.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                            <b> Conditional statements</b>
<br>
    One of the problems with <b>my_median()</b> is that the way I computed the
    middle observation is only valid for an uneven number of observations
<br>
    So we want to do different computations depending on whether the number
    of observations is even or uneven.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict off</b>
<br>
<b>: </b>
<b>: real scalar my_median(string scalar varn)</b>
<b>&gt; {</b>
<b>&gt;     x = st_data(.,varn, 0)</b>
<b>&gt;     n = rows(x)</b>
<b>&gt;     _sort(x,1)</b>
<b>&gt;     if (mod(n,2)==1) {</b>
<b>&gt;         index = ceil(n/2)</b>
<b>&gt;         median = x[index]</b>
<b>&gt;     }</b>
<b>&gt;     else {</b>
<b>&gt;         index = floor(n/2)</b>
<b>&gt;         median = x[index]</b>
<b>&gt;         index = index + 1</b>
<b>&gt;         median = (median + x[index])/2</b>
<b>&gt;     }</b>
<b>&gt;     return(median)</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. mata: my_median("tenure")</b>
<b>  3.833333254</b>
<br>
<b>. sum tenure, detail</b>
<br>
<b>                     </b>Job tenure (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>        0              0</b>
 5%    <b>      .25              0</b>
10%    <b> .5833333              0       </b>Obs         <b>      2,231</b>
25%    <b> 1.583333              0       </b>Sum of wgt. <b>      2,231</b>
<br>
50%    <b> 3.833333                      </b>Mean          <b>  5.97785</b>
<b>                        </b>Largest       Std. dev.     <b> 5.510331</b>
75%    <b> 9.333333           22.5</b>
90%    <b>    14.75       23.08333       </b>Variance      <b> 30.36375</b>
95%    <b> 17.41667          24.75       </b>Skewness      <b> 1.044433</b>
99%    <b> 20.83333       25.91667       </b>Kurtosis      <b> 3.166485</b>
<br>
<b>. mata: my_median("ttl_exp")</b>
<b>  13.12500048</b>
<br>
<b>. sum ttl_exp, detail</b>
<br>
<b>                </b>Total work experience (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b> 1.923077       .1153846</b>
 5%    <b> 4.442308       .4038461</b>
10%    <b> 6.012821       .6923077       </b>Obs         <b>      2,246</b>
25%    <b> 9.211538       .7115384       </b>Sum of wgt. <b>      2,246</b>
<br>
50%    <b>   13.125                      </b>Mean          <b> 12.53498</b>
<b>                        </b>Largest       Std. dev.     <b> 4.610208</b>
75%    <b> 15.98077       26.53846</b>
90%    <b> 18.15385       26.84615       </b>Variance      <b> 21.25401</b>
95%    <b> 19.19231        27.1923       </b>Skewness      <b>-.2360455</b>
99%    <b> 21.41667       28.88461       </b>Kurtosis      <b> 2.599452</b>
<br>
</pre>
<div class="txt"><pre>
    Unlike Stata, in Mata we need parantheses after <b>if()</b>
<br>
    The condition is between the parantheses
<br>
    Within the braces is what we do when that condition is met
<br>
    We can chain conditions with <b>else if ()</b> and finally <b>else</b>
<br>
    Another thing we might want add to our function is a check if the
    variable we receive is a numeric variable
<br>
    If that is not true, we should return an error message
<br>
</pre>
</div><pre class="output">
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict off</b>
<br>
<b>: </b>
<b>: real scalar my_median(string scalar varn)</b>
<b>&gt; {</b>
<b>&gt;     if (st_isnumvar(varn)==0) exit(error(108))</b>
<b>&gt;     </b>
<b>&gt;     x = st_data(.,varn, 0)</b>
<b>&gt;     n = rows(x)</b>
<b>&gt;     _sort(x,1)</b>
<b>&gt;     if (mod(n,2)==1) {</b>
<b>&gt;         index = ceil(n/2)</b>
<b>&gt;         median = x[index]</b>
<b>&gt;     }</b>
<b>&gt;     else {</b>
<b>&gt;         index = floor(n/2)</b>
<b>&gt;         median = x[index]</b>
<b>&gt;         index = index + 1</b>
<b>&gt;         median = (median + x[index])/2</b>
<b>&gt;     }</b>
<b>&gt;     return(median)</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. mata: my_median("tenure")</b>
<b>  3.833333254</b>
<br>
<b>. sum tenure, detail</b>
<br>
<b>                     </b>Job tenure (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>        0              0</b>
 5%    <b>      .25              0</b>
10%    <b> .5833333              0       </b>Obs         <b>      2,231</b>
25%    <b> 1.583333              0       </b>Sum of wgt. <b>      2,231</b>
<br>
50%    <b> 3.833333                      </b>Mean          <b>  5.97785</b>
<b>                        </b>Largest       Std. dev.     <b> 5.510331</b>
75%    <b> 9.333333           22.5</b>
90%    <b>    14.75       23.08333       </b>Variance      <b> 30.36375</b>
95%    <b> 17.41667          24.75       </b>Skewness      <b> 1.044433</b>
99%    <b> 20.83333       25.91667       </b>Kurtosis      <b> 3.166485</b>
<br>
<b>. mata: my_median("ttl_exp")</b>
<b>  13.12500048</b>
<br>
<b>. sum ttl_exp, detail</b>
<br>
<b>                </b>Total work experience (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b> 1.923077       .1153846</b>
 5%    <b> 4.442308       .4038461</b>
10%    <b> 6.012821       .6923077       </b>Obs         <b>      2,246</b>
25%    <b> 9.211538       .7115384       </b>Sum of wgt. <b>      2,246</b>
<br>
50%    <b>   13.125                      </b>Mean          <b> 12.53498</b>
<b>                        </b>Largest       Std. dev.     <b> 4.610208</b>
75%    <b> 15.98077       26.53846</b>
90%    <b> 18.15385       26.84615       </b>Variance      <b> 21.25401</b>
95%    <b> 19.19231        27.1923       </b>Skewness      <b>-.2360455</b>
99%    <b> 21.41667       28.88461       </b>Kurtosis      <b> 2.599452</b>
<br>
<b>. </b>
<b>. decode industry, gen(str_ind)</b>
<br>
<b>. mata: my_median("str_ind")</b>
not possible with string variable
r(108);
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide31.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide33.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide33.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Check if the variable is numeric in your <b>my_mean()</b> function
<br>
</pre>
<pre><a href="#app5">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide32.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide34.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide34.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                    <b> loops</b>
<br>
    What if we want to allow for multiple variables?
<br>
    We could split up the scalar varn into words (in this case variable
    names) with <b>tokens()</b>
<br>
    The number of columns is the number of variables
<br>
    We can loop over those
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict off</b>
<br>
<b>: </b>
<b>: real rowvector my_median(string scalar varn)</b>
<b>&gt; {</b>
<b>&gt;     varn = tokens(varn)</b>
<b>&gt;     k = cols(varn)</b>
<b>&gt;     median = J(1,k,.)</b>
<b>&gt;     </b>
<b>&gt;     for(i=1; i&lt;=k; i++) {</b>
<b>&gt;         if (st_isnumvar(varn[i])==0) exit(error(108))   </b>
<b>&gt;         x = st_data(.,varn[i], 0)</b>
<b>&gt;         n = rows(x)</b>
<b>&gt;         _sort(x,1)</b>
<b>&gt;         if (mod(n,2)==1) {</b>
<b>&gt;             index = ceil(n/2)</b>
<b>&gt;             median[i] = x[index]</b>
<b>&gt;         }</b>
<b>&gt;         else {</b>
<b>&gt;             index = floor(n/2)</b>
<b>&gt;             median[i] = x[index]</b>
<b>&gt;             index = index + 1</b>
<b>&gt;             median[i] = (median[i] + x[index])/2</b>
<b>&gt;         }</b>
<b>&gt;     }</b>
<b>&gt;     </b>
<b>&gt;     return(median)</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. mata: my_median("tenure ttl_exp")</b>
<b>       </b>          1             2
    +-----------------------------+
  1 |  <b>3.833333254   13.12500048</b>  |
    +-----------------------------+
<br>
<b>. sum tenure ttl_exp, detail</b>
<br>
<b>                     </b>Job tenure (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>        0              0</b>
 5%    <b>      .25              0</b>
10%    <b> .5833333              0       </b>Obs         <b>      2,231</b>
25%    <b> 1.583333              0       </b>Sum of wgt. <b>      2,231</b>
<br>
50%    <b> 3.833333                      </b>Mean          <b>  5.97785</b>
<b>                        </b>Largest       Std. dev.     <b> 5.510331</b>
75%    <b> 9.333333           22.5</b>
90%    <b>    14.75       23.08333       </b>Variance      <b> 30.36375</b>
95%    <b> 17.41667          24.75       </b>Skewness      <b> 1.044433</b>
99%    <b> 20.83333       25.91667       </b>Kurtosis      <b> 3.166485</b>
<br>
<b>                </b>Total work experience (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b> 1.923077       .1153846</b>
 5%    <b> 4.442308       .4038461</b>
10%    <b> 6.012821       .6923077       </b>Obs         <b>      2,246</b>
25%    <b> 9.211538       .7115384       </b>Sum of wgt. <b>      2,246</b>
<br>
50%    <b>   13.125                      </b>Mean          <b> 12.53498</b>
<b>                        </b>Largest       Std. dev.     <b> 4.610208</b>
75%    <b> 15.98077       26.53846</b>
90%    <b> 18.15385       26.84615       </b>Variance      <b> 21.25401</b>
95%    <b> 19.19231        27.1923       </b>Skewness      <b>-.2360455</b>
99%    <b> 21.41667       28.88461       </b>Kurtosis      <b> 2.599452</b>
<br>
</pre>
<div class="txt"><pre>
    So a loop happens with the <b>for()</b> functions
<br>
    It expects three arguments:
        The first tells where the loop starts
        The second tells how long the the loop has to continue
        The third tells what happens at the end of each iteration/step
<br>
<br>
    An alternative way to loop is with the <b>while()</b> function
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide33.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide35.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide35.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Change your <b>my_mean()</b> function to allow for multiple variables
<br>
</pre>
<pre><a href="#app6">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide34.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide36.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide36.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                            <b> declare your variables</b>
<br>
    It is good practice to first declare the variables you make in a
    functions, that is, tell Mata what kind of variable it is
<br>
    This will make your function (a bit) faster
<br>
    It provides a built in check whether what you create is actually what you
    think it should be.
<br>
    You can force yourself to declare your variables by setting <b>matastrict</b> to
    on.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: real rowvector my_median(string scalar varn)</b>
<b>&gt; {</b>
<b>&gt;     real scalar k, i, n, index</b>
<b>&gt;     real rowvector median</b>
<b>&gt;     real colvector x</b>
<b>&gt;     </b>
<b>&gt;     varn = tokens(varn)</b>
<b>&gt;     k = cols(varn)</b>
<b>&gt;     median = J(1,k,.)</b>
<b>&gt;     </b>
<b>&gt;     for(i=1; i&lt;=k; i++) {</b>
<b>&gt;         if (st_isnumvar(varn[i])==0) exit(error(108))   </b>
<b>&gt;         x = st_data(.,varn[i], 0)</b>
<b>&gt;         n = rows(x)</b>
<b>&gt;         _sort(x,1)</b>
<b>&gt;         if (mod(n,2)==1) {</b>
<b>&gt;             index = ceil(n/2)</b>
<b>&gt;             median[i] = x[index]</b>
<b>&gt;         }</b>
<b>&gt;         else {</b>
<b>&gt;             index = floor(n/2)</b>
<b>&gt;             median[i] = x[index]</b>
<b>&gt;             index = index + 1</b>
<b>&gt;             median[i] = (median[i] + x[index])/2</b>
<b>&gt;         }</b>
<b>&gt;     }</b>
<b>&gt;     </b>
<b>&gt;     return(median)</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. mata: my_median("tenure ttl_exp")</b>
<b>       </b>          1             2
    +-----------------------------+
  1 |  <b>3.833333254   13.12500048</b>  |
    +-----------------------------+
<br>
<b>. sum tenure ttl_exp, detail</b>
<br>
<b>                     </b>Job tenure (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>        0              0</b>
 5%    <b>      .25              0</b>
10%    <b> .5833333              0       </b>Obs         <b>      2,231</b>
25%    <b> 1.583333              0       </b>Sum of wgt. <b>      2,231</b>
<br>
50%    <b> 3.833333                      </b>Mean          <b>  5.97785</b>
<b>                        </b>Largest       Std. dev.     <b> 5.510331</b>
75%    <b> 9.333333           22.5</b>
90%    <b>    14.75       23.08333       </b>Variance      <b> 30.36375</b>
95%    <b> 17.41667          24.75       </b>Skewness      <b> 1.044433</b>
99%    <b> 20.83333       25.91667       </b>Kurtosis      <b> 3.166485</b>
<br>
<b>                </b>Total work experience (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b> 1.923077       .1153846</b>
 5%    <b> 4.442308       .4038461</b>
10%    <b> 6.012821       .6923077       </b>Obs         <b>      2,246</b>
25%    <b> 9.211538       .7115384       </b>Sum of wgt. <b>      2,246</b>
<br>
50%    <b>   13.125                      </b>Mean          <b> 12.53498</b>
<b>                        </b>Largest       Std. dev.     <b> 4.610208</b>
75%    <b> 15.98077       26.53846</b>
90%    <b> 18.15385       26.84615       </b>Variance      <b> 21.25401</b>
95%    <b> 19.19231        27.1923       </b>Skewness      <b>-.2360455</b>
99%    <b> 21.41667       28.88461       </b>Kurtosis      <b> 2.599452</b>
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide35.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide37.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide37.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Change your <b>my_mean()</b> function by declaring your variables first
<br>
</pre>
<pre><a href="#app7">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide36.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide38.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide38.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                  <b> Make your function part of a Stata program</b>
<br>
    The users of our functions will often want to use our functions from
    Stata and not Mata
<br>
    So we need a Stata program to interface between the users and our
    function
<br>
    Moreover, there are lots of convenient tools in Stata for parcing
    standard syntax and displaying standard output
<br>
</pre>
</div><pre class="output">
<br>
<b>. program drop _all</b>
<br>
<b>. program define my_median, rclass</b>
  1<b>.     version 16</b>
  2<b>.     syntax varlist(numeric) </b>
  3<b>.     </b>
<b>.     tempname res</b>
  4<b>.     mata: my_median("`varlist'")</b>
  5<b>.     matrix colnames `res' = `varlist'</b>
  6<b>.     matrix rownames `res' = "median"</b>
  7<b>.     matlist `res'</b>
  8<b>.     return matrix median = `res'</b>
  9<b>. end</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void my_median(string scalar varn )</b>
<b>&gt; {</b>
<b>&gt;     real scalar k, i, n, index</b>
<b>&gt;     real rowvector median</b>
<b>&gt;     real colvector x</b>
<b>&gt;     </b>
<b>&gt;     varn = tokens(varn)</b>
<b>&gt;     k = cols(varn)</b>
<b>&gt;     median = J(1,k,.)</b>
<b>&gt;     </b>
<b>&gt;     for(i=1; i&lt;=k; i++) {</b>
<b>&gt;         x = st_data(.,varn[i], 0)</b>
<b>&gt;         n = rows(x)</b>
<b>&gt;         _sort(x,1)</b>
<b>&gt;         if (mod(n,2)==1) {</b>
<b>&gt;             index = ceil(n/2)</b>
<b>&gt;             median[i] = x[index]</b>
<b>&gt;         }</b>
<b>&gt;         else {</b>
<b>&gt;             index = floor(n/2)</b>
<b>&gt;             median[i] = x[index]</b>
<b>&gt;             index = index + 1</b>
<b>&gt;             median[i] = (median[i] + x[index])/2</b>
<b>&gt;         }</b>
<b>&gt;     }</b>
<b>&gt;     </b>
<b>&gt;     st_matrix(st_local("res"),median)</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. my_median tenure ttl_exp</b>
<br>
             |    tenure    ttl_exp 
-------------+----------------------
      median | <b> 3.833333</b>  <b>   13.125</b> 
<br>
<b>. sum tenure ttl_exp, detail</b>
<br>
<b>                     </b>Job tenure (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>        0              0</b>
 5%    <b>      .25              0</b>
10%    <b> .5833333              0       </b>Obs         <b>      2,231</b>
25%    <b> 1.583333              0       </b>Sum of wgt. <b>      2,231</b>
<br>
50%    <b> 3.833333                      </b>Mean          <b>  5.97785</b>
<b>                        </b>Largest       Std. dev.     <b> 5.510331</b>
75%    <b> 9.333333           22.5</b>
90%    <b>    14.75       23.08333       </b>Variance      <b> 30.36375</b>
95%    <b> 17.41667          24.75       </b>Skewness      <b> 1.044433</b>
99%    <b> 20.83333       25.91667       </b>Kurtosis      <b> 3.166485</b>
<br>
<b>                </b>Total work experience (years)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b> 1.923077       .1153846</b>
 5%    <b> 4.442308       .4038461</b>
10%    <b> 6.012821       .6923077       </b>Obs         <b>      2,246</b>
25%    <b> 9.211538       .7115384       </b>Sum of wgt. <b>      2,246</b>
<br>
50%    <b>   13.125                      </b>Mean          <b> 12.53498</b>
<b>                        </b>Largest       Std. dev.     <b> 4.610208</b>
75%    <b> 15.98077       26.53846</b>
90%    <b> 18.15385       26.84615       </b>Variance      <b> 21.25401</b>
95%    <b> 19.19231        27.1923       </b>Skewness      <b>-.2360455</b>
99%    <b> 21.41667       28.88461       </b>Kurtosis      <b> 2.599452</b>
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide37.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide39.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide39.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Create a Stata program for your <b>my_mean()</b> function
<br>
</pre>
<pre><a href="#app8">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide38.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide40.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide40.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                          <b> Turn it into an .ado file</b>
<br>
    Now all we need to do is clean it up and store it as an .ado file
<br>
</pre>
</div><pre class="code">
<code>*! version 1.0.0 MLB 06Oct2021</code>
<code>program define my_median, rclass</code>
<code>    version 16</code>
<code>    syntax varlist(numeric) </code>
<code>    </code>
<code>    tempname res</code>
<code>    mata: my_median("`varlist'")</code>
<code>    matrix colnames `res' = `varlist'</code>
<code>    matrix rownames `res' = "median"</code>
<code>    matlist `res'</code>
<code>    return matrix median = `res'</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_median(string scalar varn )</code>
<code>{</code>
<code>	real scalar k, i, n, index</code>
<code>    real rowvector median</code>
<code>    real colvector x</code>
<code>    </code>
<code>	varn = tokens(varn)</code>
<code>    k = cols(varn)</code>
<code>    median = J(1,k,.)</code>
<code>    </code>
<code>    for(i=1; i&lt;=k; i++) {</code>
<code>        x = st_data(.,varn[i], 0)</code>
<code>        n = rows(x)</code>
<code>        _sort(x,1)</code>
<code>        if (mod(n,2)==1) {</code>
<code>            index = ceil(n/2)</code>
<code>            median[i] = x[index]</code>
<code>        }</code>
<code>        else {</code>
<code>            index = floor(n/2)</code>
<code>            median[i] = x[index]</code>
<code>            index = index + 1</code>
<code>            median[i] = (median[i] + x[index])/2</code>
<code>        }</code>
<code>    }</code>
<code>    </code>
<code>    st_matrix(st_local("res"),median)</code>
<code>}</code>
<code>end</code>
</pre>
<div class="txt"><pre>
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto</b>
(1978 automobile data)
<br>
<b>. my_median price mpg</b>
<br>
             |     price        mpg 
-------------+----------------------
      median | <b>   5006.5</b>  <b>       20</b> 
<br>
<b>. sum price mpg, d</b>
<br>
<b>                            </b>Price
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>     3291           3291</b>
 5%    <b>     3748           3299</b>
10%    <b>     3895           3667       </b>Obs         <b>         74</b>
25%    <b>     4195           3748       </b>Sum of wgt. <b>         74</b>
<br>
50%    <b>   5006.5                      </b>Mean          <b> 6165.257</b>
<b>                        </b>Largest       Std. dev.     <b> 2949.496</b>
75%    <b>     6342          13466</b>
90%    <b>    11385          13594       </b>Variance      <b>  8699526</b>
95%    <b>    13466          14500       </b>Skewness      <b> 1.653434</b>
99%    <b>    15906          15906       </b>Kurtosis      <b> 4.819188</b>
<br>
<b>                        </b>Mileage (mpg)
-------------------------------------------------------------
      Percentiles      Smallest
 1%    <b>       12             12</b>
 5%    <b>       14             12</b>
10%    <b>       14             14       </b>Obs         <b>         74</b>
25%    <b>       18             14       </b>Sum of wgt. <b>         74</b>
<br>
50%    <b>       20                      </b>Mean          <b>  21.2973</b>
<b>                        </b>Largest       Std. dev.     <b> 5.785503</b>
75%    <b>       25             34</b>
90%    <b>       29             35       </b>Variance      <b> 33.47205</b>
95%    <b>       34             35       </b>Skewness      <b> .9487176</b>
99%    <b>       41             41       </b>Kurtosis      <b> 3.975005</b>
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide39.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide41.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide41.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- basics
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Make your own .ado file for <b>my_mean</b>
<br>
</pre>
<pre><a href="#app9">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide40.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide42.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide42.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Linear regression and instrumental variable regression
-------------------------------------------------------------------------------
<br>
                      <b> turn our Mata code into a function</b>
<br>
    Lets revist our linear regression
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. gen byte touse = !missing(wage, grade, union, ttl_exp, tenure, south)</b>
<br>
<b>. </b>
<b>. tempname b V</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: X=y=.</b>
<br>
<b>: st_view(X,.,"grade union ttl_exp tenure south", "touse")</b>
<br>
<b>: st_view(y,.,"wage", "touse")</b>
<br>
<b>: XX = cross(X,1, X,1)</b>
<br>
<b>: Xy = cross(X,1, y,0)</b>
<br>
<b>: b = invsym(XX)*Xy</b>
<br>
<b>: </b>
<b>: N = rows(X)</b>
<br>
<b>: k = cols(X) + 1</b>
<br>
<b>: cons = J(N,1,1)</b>
<br>
<b>: res = y - (X,cons)*b</b>
<br>
<b>: ess = cross(res,res)</b>
<br>
<b>: s2 = ess/(N-k)</b>
<br>
<b>: Var = s2*invsym(XX)</b>
<br>
<b>: </b>
<b>: st_matrix(st_local("b"), b')</b>
<br>
<b>: st_matrix(st_local("V"), Var)</b>
<br>
<b>: st_local("df_r", strofreal(N-k))</b>
<br>
<b>: st_local("N", strofreal(N))</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. local xnames `""grade" "union" "ttl_exp" "tenure" "south" "_cons""'</b>
<br>
<b>. matrix colnames `b' = `xnames'</b>
<br>
<b>. matrix colnames `V' = `xnames'</b>
<br>
<b>. matrix rownames `V' = `xnames'</b>
<br>
<b>. ereturn post `b' `V', dof(`df_r') obs(`N') esample(touse)</b>
<br>
<b>. ereturn display</b>
------------------------------------------------------------------------------
             | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. reg wage grade union ttl_exp tenure south</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,866</b>
-------------+----------------------------------   F(5, 1860)      = <b>   158.02</b>
       Model | <b> 9668.81879         5  1933.76376   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22761.2079     1,860  12.2372085   </b>R-squared       =<b>    0.2981</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2963</b>
       Total | <b> 32430.0267     1,865  17.3887542   </b>Root MSE        =   <b> 3.4982</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    To turn this into function we want the name of the dependent independent
    and selection variable to be arguments
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. gen byte touse = !missing(wage, grade, union, ttl_exp, tenure, south)</b>
<br>
<b>. </b>
<b>. tempname b V</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void my_regress(string scalar depvar, string scalar indepvars, string scalar </b>
<b>&gt; select)</b>
<b>&gt; {</b>
<b>&gt;     transmorphic X, y</b>
<b>&gt;     real matrix XX, Xy, Var</b>
<b>&gt;     real colvector b, cons, res</b>
<b>&gt;     real scalar N, k, ess, s2</b>
<b>&gt;     </b>
<b>&gt;     X=y=.</b>
<b>&gt;     st_view(X,.,indepvars, select)</b>
<b>&gt;     st_view(y,.,depvar, select)</b>
<b>&gt;     XX = cross(X,1, X,1)</b>
<b>&gt;     Xy = cross(X,1, y,0)</b>
<b>&gt;     b = invsym(XX)*Xy</b>
<b>&gt; </b>
<b>&gt;     N = rows(X)</b>
<b>&gt;     k = cols(X) + 1</b>
<b>&gt;     cons = J(N,1,1)</b>
<b>&gt;     res = y - (X,cons)*b</b>
<b>&gt;     ess = cross(res,res)</b>
<b>&gt;     s2 = ess/(N-k)</b>
<b>&gt;     Var = s2*invsym(XX)</b>
<b>&gt; </b>
<b>&gt;     st_matrix(st_local("b"), b')</b>
<b>&gt;     st_matrix(st_local("V"), Var)</b>
<b>&gt;     st_local("df_r", strofreal(N-k))</b>
<b>&gt;     st_local("N", strofreal(N))</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. mata: my_regress("wage", "grade union ttl_exp tenure south", "touse")</b>
<br>
<b>. local xnames `""grade" "union" "ttl_exp" "tenure" "south" "_cons""'</b>
<br>
<b>. matrix colnames `b' = `xnames'</b>
<br>
<b>. matrix colnames `V' = `xnames'</b>
<br>
<b>. matrix rownames `V' = `xnames'</b>
<br>
<b>. ereturn post `b' `V', dof(`df_r') obs(`N') esample(touse)</b>
<br>
<b>. ereturn display</b>
------------------------------------------------------------------------------
             | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. reg wage grade union ttl_exp tenure south</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,866</b>
-------------+----------------------------------   F(5, 1860)      = <b>   158.02</b>
       Model | <b> 9668.81879         5  1933.76376   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22761.2079     1,860  12.2372085   </b>R-squared       =<b>    0.2981</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2963</b>
       Total | <b> 32430.0267     1,865  17.3887542   </b>Root MSE        =   <b> 3.4982</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide41.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide43.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide43.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Linear regression and instrumental variable regression
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Do the same for your 2sls model
<br>
    As arguments we want the dependent variable, the exogenous variable, the
    endogenous variables, the instruments, the constant, and the selection
    variable.
<br>
    To get the variables for the <b>X</b> matrix we need to combine the names of the
    exogenous, endogenous, and the constant
<br>
    To get the variables for the <b>Z</b> matrix we need to combine the names of the
    exogenous, instruments, and the constant
<br>
    We can combine string scalars with <b>+</b>, but don't forget to add a space
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: greetings = "Hello"</b>
<br>
<b>: who = "world"</b>
<br>
<b>: greetings + who</b>
<b>  Helloworld</b>
<br>
<b>: greetings + " " + who</b>
<b>  Hello world</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
</pre>
<pre><a href="#app10">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide42.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide44.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide44.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Linear regression and instrumental variable regression
-------------------------------------------------------------------------------
<br>
                         <b> Turn it into a Stata program</b>
<br>
    Now we can turn it into a Stata program
<br>
    We can use <b>marksample</b> to create our selection variable, this enables use
    to allow standard <b>if</b> and <b>in</b> conditions for our program
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void my_regress(string scalar depvar, string scalar indepvars, string scalar </b>
<b>&gt; select)</b>
<b>&gt; {</b>
<b>&gt;     transmorphic X, y</b>
<b>&gt;     real matrix XX, Xy, Var</b>
<b>&gt;     real colvector b, cons, res</b>
<b>&gt;     real scalar N, k, ess, s2</b>
<b>&gt;     </b>
<b>&gt;     X=y=.</b>
<b>&gt;     st_view(X,.,indepvars, select)</b>
<b>&gt;     st_view(y,.,depvar, select)</b>
<b>&gt;     XX = cross(X,1, X,1)</b>
<b>&gt;     Xy = cross(X,1, y,0)</b>
<b>&gt;     b = invsym(XX)*Xy</b>
<b>&gt; </b>
<b>&gt;     N = rows(X)</b>
<b>&gt;     k = cols(X) + 1</b>
<b>&gt;     cons = J(N,1,1)</b>
<b>&gt;     res = y - (X,cons)*b</b>
<b>&gt;     ess = cross(res,res)</b>
<b>&gt;     s2 = ess/(N-k)</b>
<b>&gt;     Var = s2*invsym(XX)</b>
<b>&gt; </b>
<b>&gt;     st_matrix(st_local("b"), b')</b>
<b>&gt;     st_matrix(st_local("V"), Var)</b>
<b>&gt;     st_local("df_r", strofreal(N-k))</b>
<b>&gt;     st_local("N", strofreal(N))</b>
<b>&gt; }</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. </b>
<b>. program drop _all</b>
<br>
<b>. program define my_regress, eclass</b>
  1<b>.     version 16</b>
  2<b>.     syntax varlist(numeric) [if] [in]</b>
  3<b>.     </b>
<b>.     marksample touse</b>
  4<b>.     </b>
<b>.     tempname b V</b>
  5<b>.     </b>
<b>.     gettoken y x : varlist</b>
  6<b>.     </b>
<b>.     mata: my_regress("`y'", "`x'", "`touse'")</b>
  7<b>.     matrix colnames `b' = `x' "_cons"</b>
  8<b>.     matrix colnames `V' = `x' "_cons"</b>
  9<b>.     matrix rownames `V' = `x' "_cons"</b>
 10<b>.     ereturn post `b' `V', dof(`df_r') obs(`N') esample(`touse') depname("`</b>
<b>&gt; y'")</b>
 11<b>.     ereturn display</b>
 12<b>. end</b>
<br>
<b>. </b>
<b>. sysuse nlsw88, clear</b>
(NLSW, 1988 extract)
<br>
<b>. </b>
<b>. my_regress wage grade union ttl_exp tenure south</b>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
<b>. reg wage grade union ttl_exp tenure south</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>     1,866</b>
-------------+----------------------------------   F(5, 1860)      = <b>   158.02</b>
       Model | <b> 9668.81879         5  1933.76376   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b> 22761.2079     1,860  12.2372085   </b>R-squared       =<b>    0.2981</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.2963</b>
       Total | <b> 32430.0267     1,865  17.3887542   </b>Root MSE        =   <b> 3.4982</b>
<br>
------------------------------------------------------------------------------
        wage | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       grade |<b>   .5910388   .0324833    18.20   0.000     .5273312    .6547465</b>
       union |<b>   .7654532   .1922649     3.98   0.000     .3883755    1.142531</b>
     ttl_exp |<b>   .2348585   .0219678    10.69   0.000     .1917744    .2779426</b>
      tenure |<b>   .0412964   .0178785     2.31   0.021     .0062324    .0763603</b>
       south |<b>  -.9976963   .1663997    -6.00   0.000    -1.324046   -.6713466</b>
       _cons |<b>  -3.245932    .468053    -6.93   0.000    -4.163897   -2.327968</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide43.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide45.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide45.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Linear regression and instrumental variable regression
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Do the same to your 2sls program
<br>
    The <b>syntax</b> I would use is:
<br>
<br>
<b>    syntax varlist(numeric) [if] [in], ///</b>
<b>         endog(varlist numeric)        ///</b>
<b>         instruments(varlist numeric)</b>
<br>
<br>
    The first variable in varlist is the dependent, and the remaining
    variables are the exogenous variables.
<br>
</pre>
<pre><a href="#app11">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide44.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide46.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide46.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Linear regression and instrumental variable regression
-------------------------------------------------------------------------------
<br>
                           <b> Turn it into a .ado file</b>
<br>
    As before, all we need to do is clean up, put the Mata code at the bottom
    of the file, and save it as an .ado file
<br>
</pre>
</div><pre class="code">
<code>*! version 1.0.0 MLB 06Oct2021</code>
<code>program define my_regress, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(numeric) [if] [in]</code>
<code>    </code>
<code>    marksample touse</code>
<code>    </code>
<code>    tempname b V</code>
<code>    </code>
<code>    gettoken y x : varlist</code>
<code>    </code>
<code>    mata: my_regress("`y'", "`x'", "`touse'")</code>
<code>    matrix colnames `b' = `x' "_cons"</code>
<code>    matrix colnames `V' = `x' "_cons"</code>
<code>    matrix rownames `V' = `x' "_cons"</code>
<code>    ereturn post `b' `V', dof(`df_r') obs(`N') esample(`touse') depname("`y'")</code>
<code>    ereturn display</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_regress(string scalar depvar, string scalar indepvars, string scalar select)</code>
<code>{</code>
<code>	transmorphic X, y</code>
<code>    real matrix XX, Xy, Var</code>
<code>    real colvector b, cons, res</code>
<code>    real scalar N, k, ess, s2</code>
<code>    </code>
<code>    X=y=.</code>
<code>    st_view(X,.,indepvars, select)</code>
<code>    st_view(y,.,depvar, select)</code>
<code>    XX = cross(X,1, X,1)</code>
<code>    Xy = cross(X,1, y,0)</code>
<code>    b = invsym(XX)*Xy</code>
<code></code>
<code>    N = rows(X)</code>
<code>    k = cols(X) + 1</code>
<code>    cons = J(N,1,1)</code>
<code>    res = y - (X,cons)*b</code>
<code>    ess = cross(res,res)</code>
<code>    s2 = ess/(N-k)</code>
<code>    Var = s2*invsym(XX)</code>
<code></code>
<code>    st_matrix(st_local("b"), b')</code>
<code>    st_matrix(st_local("V"), Var)</code>
<code>    st_local("df_r", strofreal(N-k))</code>
<code>    st_local("N", strofreal(N))</code>
<code>}</code>
<code>end</code>
<code></code>
</pre>
<div class="txt"><pre>
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto</b>
(1978 automobile data)
<br>
<b>. my_regress price weight length mpg</b>
------------------------------------------------------------------------------
       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
      weight |<b>   4.364798   1.167455     3.74   0.000     2.036383    6.693213</b>
      length |<b>  -104.8682   39.72154    -2.64   0.010    -184.0903   -25.64607</b>
         mpg |<b>  -86.78928   83.94335    -1.03   0.305     -254.209    80.63046</b>
       _cons |<b>   14542.43   5890.632     2.47   0.016      2793.94    26290.93</b>
------------------------------------------------------------------------------
<br>
<b>. regress price weight length mpg</b>
<br>
      Source |       SS           df       MS      Number of obs   =<b>        74</b>
-------------+----------------------------------   F(3, 70)        = <b>    12.98</b>
       Model | <b>  226957412         3  75652470.6   </b>Prob &gt; F        =<b>    0.0000</b>
    Residual | <b>  408107984        70  5830114.06   </b>R-squared       =<b>    0.3574</b>
-------------+----------------------------------   Adj R-squared   =<b>    0.3298</b>
       Total | <b>  635065396        73  8699525.97   </b>Root MSE        =   <b> 2414.6</b>
<br>
------------------------------------------------------------------------------
       price | Coefficient  Std. err.      t    P&gt;|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
      weight |<b>   4.364798   1.167455     3.74   0.000     2.036383    6.693213</b>
      length |<b>  -104.8682   39.72154    -2.64   0.010    -184.0903   -25.64607</b>
         mpg |<b>  -86.78928   83.94335    -1.03   0.305     -254.209    80.63046</b>
       _cons |<b>   14542.43   5890.632     2.47   0.016      2793.94    26290.93</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide45.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide47.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide47.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Linear regression and instrumental variable regression
-------------------------------------------------------------------------------
<br>
                                <b> Do it yourself</b>
<br>
    Do the same to your 2sls program
<br>
</pre>
<pre><a href="#app12">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide46.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide48.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide48.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                              <b> Maximum Likelihood</b>
<br>
    You start with a model, which has parameters, and dataset
<br>
    Find those parameters that maximize the probability of observing the data
    assuming the model is true
<br>
    <b>Example:</b>
<br>
        We want to know the probability that someone is a member of a trade
        union
<br>
        Data: N persons and a binary variable <i>union</i>, which is 1 when the
        person is a union member, and 0 when not
<br>
        The model: There is a fixed probability <i>pi</i> that a person is a member
<br>
        The likelihood: If someone is a member, then the probability of
        seeing such a person is <i>pi</i>
<br>
        If someone is not a member then the probability of observing that
        person is (1-<i>pi</i>)
<br>
        Say we observe 3 union members and 2 non-members, then the likelihood
        is :
<br>
        L(<i>pi</i>|data) = <i>pi</i>*<i>pi</i>*<i>pi</i>*(1-<i>pi</i>)*(1-<i>pi</i>)
<br>
        L(<i>pi</i>|data) = Prod(<i>pi</i>^union * (1-<i>pi</i>)^(1-union)
<br>
        We need to find the value of <i>pi</i> that maximizes L
<br>
    It is actually more convenient to maximize the log of the likelihood
<br>
    Remember:
        ln(a*b) = ln(a) + ln(b)
        ln(a^b) = b ln(a)
<br>
        ln(L(<i>pi</i>|data)) = ln(Prod(<i>pi</i>^union * (1-<i>pi</i>)^(1-union))
<br>
        ln(L(<i>pi</i>|data)) = sum(ln(<i>pi</i>^union) + ln((1-<i>pi</i>)^(1-union))
<br>
        ln(L(<i>pi</i>|data)) = sum(union*ln(<i>pi</i>) + (1-union)*ln(1-<i>pi</i>)
<br>
    Typically, we don't think there is one probability for everybody, but we
    are interested in how that probability differs depending on explanatory
    variables
<br>
    So we replace <i>pi</i> with a function of of those explanatory variables
<br>
    A common choice is the logit function:
        xb = b_0 + b_1 x_1 + b_2 x_2 + ...
        <i>pi</i>= exp(xb)/(1-exp(xb)) = invlogit(xb)
<br>
    This is logistic regression
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide47.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide49.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide49.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                          <b> Maximum Likelihood in Mata</b>
<br>
    In Mata you can use <b>moptimize</b> to find the maximum likelihood estimates
    and its variance covariance matrix
<br>
    In fact, it is more general than that: it can be used to maximize or
    minimize any function, e.g. find gmm estimates.
<br>
    Using <b>moptimize</b> is a multi-step process
        1. Create a function that takes parameter values and data and returns
        the log-likelihood value (or gmm, or ...)
        2. Initialize, i.e. create an object that stores everything Mata
        needs for this problem
        3. Give that object the information it needs, at least the function
        and the data
        4. Let moptimize find the optimum
        5. Display the results
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: // Step 1</b>
<b>: void logiteval(transmorphic M, real rowvector b, real colvector lnf)</b>
<b>&gt; {</b>
<b>&gt;     real colvector xb</b>
<b>&gt;     real colvector y</b>
<b>&gt;     </b>
<b>&gt;     xb = moptimize_util_xb(M, b, 1)</b>
<b>&gt;     y  = moptimize_util_depvar(M,1)</b>
<b>&gt;     </b>
<b>&gt;     lnf = y:*ln(invlogit(xb)) + (1:-y):*ln(invlogit(-xb)) </b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: // Step 2</b>
<b>: M = moptimize_init()</b>
<br>
<b>: </b>
<b>: // Step 3</b>
<b>: moptimize_init_evaluator(M, &amp;logiteval())</b>
<br>
<b>: moptimize_init_depvar(M, 1, "foreign")</b>
<br>
<b>: moptimize_init_eq_indepvars(M,1,"price weight") </b>
<br>
<b>: </b>
<b>: // Step 4</b>
<b>: moptimize(M)</b>
initial:       f(p) = <b>-51.292891</b>
alternative:   f(p) = <b>-46.081697</b>
rescale:       f(p) = <b>-45.181365</b>
Iteration 0:   f(p) = <b>-45.181365</b>  
Iteration 1:   f(p) = <b>-23.052505</b>  
Iteration 2:   f(p) = <b>-18.629959</b>  
Iteration 3:   f(p) = <b>-17.990857</b>  
Iteration 4:   f(p) = <b>-17.976367</b>  
Iteration 5:   f(p) = <b>-17.976341</b>  
Iteration 6:   f(p) = <b>-17.976341</b>  
<br>
<b>: </b>
<b>: // Step 5</b>
<b>: moptimize_result_display(M)</b>
<br>
                                                            Number of obs = <b>74</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
       price |<b>   .0009296   .0002999     3.10   0.002     .0003418    .0015174</b>
      weight |<b>  -.0058785   .0016986    -3.46   0.001    -.0092078   -.0025493</b>
       _cons |<b>   9.000473   2.627577     3.43   0.001     3.850517    14.15043</b>
------------------------------------------------------------------------------
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. logit foreign price weight</b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b> -22.92708</b>  
Iteration 2:   log likelihood = <b>-18.834379</b>  
Iteration 3:   log likelihood = <b>-17.996532</b>  
Iteration 4:   log likelihood = <b>-17.976397</b>  
Iteration 5:   log likelihood = <b>-17.976341</b>  
Iteration 6:   log likelihood = <b>-17.976341</b>  
<br>
Logistic regression                                     Number of obs = <b>    74</b>
                                                        LR chi2(<b>2</b>)    = <b> 54.11</b>
                                                        Prob &gt; chi2   = <b>0.0000</b>
Log likelihood = <b>-17.976341</b>                             Pseudo R2     = <b>0.6008</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
       price |<b>   .0009296   .0002999     3.10   0.002     .0003418    .0015174</b>
      weight |<b>  -.0058785   .0016986    -3.46   0.001    -.0092078   -.0025493</b>
       _cons |<b>   9.000473   2.627577     3.43   0.001     3.850517    14.15043</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    In the evaluator I used <b>invlogit(-xb)</b> instead of <b>(1-invlogit(xb))</b>
<br>
    The logistic distribution is a symmetric distribution around 0, very much
    like the standard normal distribution.
<br>
    You may (vaguely) remember that 1-Phi(z) = Phi(z)
<br>
        (There was a table at the end of your Statistics book giving you the
        CDF for the standard normal distribution, and you needed to use that
        to find the probability that a drawing a value more than some <i>z</i>)
<br>
    Similarly, <b>invlogit(-xb)</b> is the same as <b>(1-invlogit(xb))</b>
<br>
    However, the former is easier for computers than the latter (precision)
<br>
    If you want to write a Maximum Likelihood model in Stata/Mata then
    (Gould, Pitblado, and Poi 2010) is highly recommended.
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide48.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide50.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide50.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                            <b> do it yourself poisson</b>
<br>
    If we assume that the dependent variable is Poisson distributed, then the
    probability of observing a person with <i>y</i> events is
<br>
        (<i>mu</i>^y exp(-<i>mu</i>))/y!
<br>
    Where <i>mu</i> is the mean number of events. In case of a Poisson the <i>lambda</i> is
    also common
<br>
    So the probability of observing the data given a value of <i>mu</i> is
<br>
        L(y|<i>mu</i>) = prod((<i>mu</i>^y exp(-<i>mu</i>))/y!)
<br>
    Taking the logarithm:
<br>
        ln(L(y|<i>mu</i>)) = ln(prod((<i>mu</i>^y exp(-<i>mu</i>))/y!))
        ln(L(y|<i>mu</i>)) = Sum(ln(<i>mu</i>^y) + ln(exp(-<i>mu</i>)) - ln(y!))
        ln(L(y|<i>mu</i>)) = Sum(y*ln(<i>mu</i>) - <i>mu</i> - ln(y!))
<br>
    The mean in case of a Poisson distribution is the expected number of
    events, so has to be positive
<br>
    We can make the mean dependent of explanatory variables and make sure
    that that mean remains positive by using exp(xb)
<br>
        ln(L(y|<i>b</i>)) = Sum(y*ln(exp(<b>Xb</b>)) - exp(<b>xb</b>) - ln(y!))
        ln(L(y|<i>b</i>)) = Sum(y*<b>Xb</b> - exp(<b>xb</b>) - ln(y!))
<br>
    Create a Poisson regression in Mata, use the horse.dta dataset, create
    indicator variables for the cavelary units and use those as explanatory
    varialbes (excluding the reference unit)
<br>
</pre>
<pre><a href="#app13">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide49.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide51.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide51.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                           <b> include in Stata program</b>
<br>
    We want to use it in a Stata program
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. program drop _all</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void logiteval(transmorphic M, real rowvector b, real colvector lnf)</b>
<b>&gt; {</b>
<b>&gt;     real colvector xb</b>
<b>&gt;     real colvector y</b>
<b>&gt;     </b>
<b>&gt;     xb = moptimize_util_xb(M, b, 1)</b>
<b>&gt;     y  = moptimize_util_depvar(M,1)</b>
<b>&gt;     </b>
<b>&gt;     lnf = y:*ln(invlogit(xb)) + (1:-y):*ln(invlogit(-xb)) </b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void logitwork(string scalar depvar, string scalar indepvars)</b>
<b>&gt; {</b>
<b>&gt;     transmorphic M</b>
<b>&gt;     M = moptimize_init()</b>
<b>&gt;     moptimize_init_evaluatortype(M, "lf")</b>
<b>&gt;     moptimize_init_evaluator(M, &amp;logiteval())</b>
<b>&gt;     moptimize_init_touse(M, st_local("touse"))</b>
<b>&gt;     moptimize_init_ndepvars(M,1)</b>
<b>&gt;     moptimize_init_depvar(M, 1, depvar)</b>
<b>&gt;     moptimize_init_eq_indepvars(M,1,indepvars) </b>
<b>&gt;     moptimize_init_valueid(M, "log likelihood")</b>
<b>&gt;     moptimize(M)</b>
<b>&gt;     moptimize_result_display(M)</b>
<b>&gt;     moptimize_result_post(M)</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. program define my_logit, eclass</b>
  1<b>.     version 16</b>
  2<b>.     syntax varlist [if] [in]</b>
  3<b>.     </b>
<b>.     marksample touse</b>
  4<b>.     </b>
<b>.     _rmcoll `varlist' if `touse' , ///</b>
<b>&gt;         logit touse(`touse')       // options specific to logit (detect perfe</b>
<b>&gt; ct predictions)</b>
  5<b>.     </b>
<b>.     local varlist `r(varlist)'</b>
  6<b>.     gettoken y x : varlist</b>
  7<b>.     </b>
<b>.     mata logitwork("`y'", "`x'")</b>
  8<b>. end</b>
<br>
<b>. </b>
<b>. my_logit foreign price weight</b>
<br>
initial:       log likelihood = <b>-51.292891</b>
alternative:   log likelihood = <b>-46.081697</b>
rescale:       log likelihood = <b>-45.181365</b>
Iteration 0:   log likelihood = <b>-45.181365</b>  
Iteration 1:   log likelihood = <b>-23.052505</b>  
Iteration 2:   log likelihood = <b>-18.629959</b>  
Iteration 3:   log likelihood = <b>-17.990857</b>  
Iteration 4:   log likelihood = <b>-17.976367</b>  
Iteration 5:   log likelihood = <b>-17.976341</b>  
Iteration 6:   log likelihood = <b>-17.976341</b>  
<br>
                                                            Number of obs = <b>74</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
       price |<b>   .0009296   .0002999     3.10   0.002     .0003418    .0015174</b>
      weight |<b>  -.0058785   .0016986    -3.46   0.001    -.0092078   -.0025493</b>
       _cons |<b>   9.000473   2.627577     3.43   0.001     3.850517    14.15043</b>
------------------------------------------------------------------------------
<br>
<b>. logit foreign price weight</b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b> -22.92708</b>  
Iteration 2:   log likelihood = <b>-18.834379</b>  
Iteration 3:   log likelihood = <b>-17.996532</b>  
Iteration 4:   log likelihood = <b>-17.976397</b>  
Iteration 5:   log likelihood = <b>-17.976341</b>  
Iteration 6:   log likelihood = <b>-17.976341</b>  
<br>
Logistic regression                                     Number of obs = <b>    74</b>
                                                        LR chi2(<b>2</b>)    = <b> 54.11</b>
                                                        Prob &gt; chi2   = <b>0.0000</b>
Log likelihood = <b>-17.976341</b>                             Pseudo R2     = <b>0.6008</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
       price |<b>   .0009296   .0002999     3.10   0.002     .0003418    .0015174</b>
      weight |<b>  -.0058785   .0016986    -3.46   0.001    -.0092078   -.0025493</b>
       _cons |<b>   9.000473   2.627577     3.43   0.001     3.850517    14.15043</b>
------------------------------------------------------------------------------
<br>
<b>. </b>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide50.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide52.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide52.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                                <b> do it yourself</b>
<br>
    Do the same for your poisson model
<br>
</pre>
<pre><a href="#app14">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide51.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide53.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide53.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                           <b> Allow factor varialbes </b>
<br>
    It would be helpful to allow Stata's factor variables
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. program drop _all</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void logiteval(transmorphic M, real rowvector b, real colvector lnf)</b>
<b>&gt; {</b>
<b>&gt;     real colvector xb</b>
<b>&gt;     real colvector y</b>
<b>&gt;     </b>
<b>&gt;     xb = moptimize_util_xb(M, b, 1)</b>
<b>&gt;     y  = moptimize_util_depvar(M,1)</b>
<b>&gt;     </b>
<b>&gt;     lnf = y:*ln(invlogit(xb)) + (1:-y):*ln(invlogit(-xb)) </b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void logitwork(string scalar depvar, string scalar indepvars)</b>
<b>&gt; {</b>
<b>&gt;     transmorphic M</b>
<b>&gt;     M = moptimize_init()</b>
<b>&gt;     moptimize_init_evaluatortype(M, "lf")</b>
<b>&gt;     moptimize_init_evaluator(M, &amp;logiteval())</b>
<b>&gt;     moptimize_init_touse(M, st_local("touse"))</b>
<b>&gt;     moptimize_init_ndepvars(M,1)</b>
<b>&gt;     moptimize_init_depvar(M, 1, depvar)</b>
<b>&gt;     moptimize_init_eq_indepvars(M,1,indepvars) </b>
<b>&gt;     moptimize_init_valueid(M, "log likelihood")</b>
<b>&gt;     moptimize(M)</b>
<b>&gt;     moptimize_result_display(M)</b>
<b>&gt;     moptimize_result_post(M)</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. program define my_logit, eclass</b>
  1<b>.     version 16</b>
  2<b>.     syntax varlist(fv ts) [if] [in]</b>
  3<b>.     </b>
<b>.     marksample touse</b>
  4<b>.     </b>
<b>.     _rmcoll `varlist' if `touse' , expand ///</b>
<b>&gt;         logit touse(`touse')       // options specific to logit (detect perfe</b>
<b>&gt; ct predictions)</b>
  5<b>.     </b>
<b>.     local varlist `r(varlist)'</b>
  6<b>.     gettoken y x : varlist</b>
  7<b>.     _fv_check_depvar `y'</b>
  8<b>.     </b>
<b>.     mata logitwork("`y'", "`x'")</b>
  9<b>. end</b>
<br>
<b>. </b>
<b>. sum price</b>
<br>
    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
       price |<b>         74    6165.257    2949.496       3291      15906</b>
<br>
<b>. gen byte expensive = price &gt; r(mean) if price &lt; .</b>
<br>
<b>. </b>
<b>. my_logit foreign i.expensive weight</b>
<br>
initial:       log likelihood = <b>-51.292891</b>
alternative:   log likelihood = <b>-46.081697</b>
rescale:       log likelihood = <b>-45.181365</b>
Iteration 0:   log likelihood = <b>-45.181365</b>  
Iteration 1:   log likelihood = <b>-24.377627</b>  
Iteration 2:   log likelihood = <b>-21.860587</b>  
Iteration 3:   log likelihood = <b>-21.769119</b>  
Iteration 4:   log likelihood = <b>-21.768986</b>  
Iteration 5:   log likelihood = <b>-21.768986</b>  
<br>
                                                            Number of obs = <b>74</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
 1.expensive |<b>    3.79774   1.291705     2.94   0.003     1.266044    6.329436</b>
      weight |<b>  -.0037119   .0008779    -4.23   0.000    -.0054326   -.0019912</b>
       _cons |<b>   8.255436    2.06364     4.00   0.000     4.210776     12.3001</b>
------------------------------------------------------------------------------
<br>
<b>. logit foreign i.expensive weight </b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b>-24.117046</b>  
Iteration 2:   log likelihood = <b>-21.897931</b>  
Iteration 3:   log likelihood = <b>-21.769135</b>  
Iteration 4:   log likelihood = <b>-21.768986</b>  
Iteration 5:   log likelihood = <b>-21.768986</b>  
<br>
Logistic regression                                     Number of obs = <b>    74</b>
                                                        LR chi2(<b>2</b>)    = <b> 46.53</b>
                                                        Prob &gt; chi2   = <b>0.0000</b>
Log likelihood = <b>-21.768986</b>                             Pseudo R2     = <b>0.5166</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
 1.expensive |<b>    3.79774   1.291705     2.94   0.003     1.266044    6.329436</b>
      weight |<b>  -.0037119   .0008779    -4.23   0.000    -.0054326   -.0019912</b>
       _cons |<b>   8.255436    2.06364     4.00   0.000     4.210776     12.3001</b>
------------------------------------------------------------------------------
<br>
<b>. </b>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide52.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide54.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide54.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                                <b> do it yourself</b>
<br>
    Do the same for your Poisson model
<br>
</pre>
<pre><a href="#app15">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide53.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide55.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide55.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                               <b> Starting values</b>
<br>
    This program can have difficulties converging, or even getting started.
<br>
    It helps to provide meaningful starting values
<br>
    In case of logit regression, we know that without covariates the
    ML-estimate of the probability is just the mean of the dependent
    variable, so estimate of the constant is ln(mean/(1-mean)), or
    logit(mean)
<br>
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. program drop _all</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void logiteval(transmorphic M, real rowvector b, real colvector lnf)</b>
<b>&gt; {</b>
<b>&gt;     real colvector xb</b>
<b>&gt;     real colvector y</b>
<b>&gt;     </b>
<b>&gt;     xb = moptimize_util_xb(M, b, 1)</b>
<b>&gt;     y  = moptimize_util_depvar(M,1)</b>
<b>&gt;     </b>
<b>&gt;     lnf = y:*ln(invlogit(xb)) + (1:-y):*ln(invlogit(-xb)) </b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void logitwork(string scalar depvar, string scalar indepvars)</b>
<b>&gt; {</b>
<b>&gt;     transmorphic M</b>
<b>&gt;     M = moptimize_init()</b>
<b>&gt;     moptimize_init_evaluatortype(M, "lf")</b>
<b>&gt;     moptimize_init_evaluator(M, &amp;logiteval())</b>
<b>&gt;     moptimize_init_touse(M, st_local("touse"))</b>
<b>&gt;     moptimize_init_ndepvars(M,1)</b>
<b>&gt;     moptimize_init_depvar(M, 1, depvar)</b>
<b>&gt;     moptimize_init_eq_indepvars(M,1,indepvars) </b>
<b>&gt;     moptimize_init_valueid(M, "log likelihood")</b>
<b>&gt;     moptimize_init_eq_coefs(M,1,st_matrix("r(b0)"))</b>
<b>&gt;     moptimize_init_search(M, "off")</b>
<b>&gt;     moptimize(M)</b>
<b>&gt;     moptimize_result_display(M)</b>
<b>&gt;     moptimize_result_post(M)</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. program define startval, rclass</b>
  1<b>.     syntax varname [if], k(integer) </b>
  2<b>.     </b>
<b>.     tempname b0</b>
  3<b>.     matrix `b0' = J(1, `k', 0)</b>
  4<b>.     </b>
<b>.     marksample touse</b>
  5<b>.     sum `varlist' if `touse', meanonly</b>
  6<b>.     matrix `b0'[1,`k'] = logit(r(mean))</b>
  7<b>.     return matrix b0 = `b0'</b>
  8<b>. </b>
<b>. end</b>
<br>
<b>. </b>
<b>. program define my_logit, eclass</b>
  1<b>.     version 16</b>
  2<b>.     syntax varlist(fv ts) [if] [in]</b>
  3<b>.     </b>
<b>.     marksample touse</b>
  4<b>.     </b>
<b>.     _rmcoll `varlist' if `touse' , expand ///</b>
<b>&gt;         logit touse(`touse')       // options specific to logit (detect perfe</b>
<b>&gt; ct predictions)</b>
  5<b>.     </b>
<b>.     local varlist `r(varlist)'</b>
  6<b>.     gettoken y x : varlist</b>
  7<b>.     _fv_check_depvar `y'</b>
  8<b>.     </b>
<b>.     local k : word count `x'</b>
  9<b>.     local k = `k' + 1 // the constant</b>
 10<b>.     startval `y' if `touse', k(`k') `constant'</b>
 11<b>.     </b>
<b>.     mata logitwork("`y'", "`x'")</b>
 12<b>. end</b>
<br>
<b>. </b>
<b>. sum price</b>
<br>
    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
       price |<b>         74    6165.257    2949.496       3291      15906</b>
<br>
<b>. gen byte expensive = price &gt; r(mean) if price &lt; .</b>
<br>
<b>. </b>
<b>. my_logit foreign i.expensive weight</b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b>-24.117046</b>  
Iteration 2:   log likelihood = <b>-21.896816</b>  
Iteration 3:   log likelihood = <b> -21.76913</b>  
Iteration 4:   log likelihood = <b>-21.768986</b>  
Iteration 5:   log likelihood = <b>-21.768986</b>  
<br>
                                                            Number of obs = <b>74</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
 1.expensive |<b>    3.79774   1.291705     2.94   0.003     1.266044    6.329436</b>
      weight |<b>  -.0037119   .0008779    -4.23   0.000    -.0054326   -.0019912</b>
       _cons |<b>   8.255436    2.06364     4.00   0.000     4.210776     12.3001</b>
------------------------------------------------------------------------------
<br>
<b>. logit foreign i.expensive weight </b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b>-24.117046</b>  
Iteration 2:   log likelihood = <b>-21.897931</b>  
Iteration 3:   log likelihood = <b>-21.769135</b>  
Iteration 4:   log likelihood = <b>-21.768986</b>  
Iteration 5:   log likelihood = <b>-21.768986</b>  
<br>
Logistic regression                                     Number of obs = <b>    74</b>
                                                        LR chi2(<b>2</b>)    = <b> 46.53</b>
                                                        Prob &gt; chi2   = <b>0.0000</b>
Log likelihood = <b>-21.768986</b>                             Pseudo R2     = <b>0.5166</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
 1.expensive |<b>    3.79774   1.291705     2.94   0.003     1.266044    6.329436</b>
      weight |<b>  -.0037119   .0008779    -4.23   0.000    -.0054326   -.0019912</b>
       _cons |<b>   8.255436    2.06364     4.00   0.000     4.210776     12.3001</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide54.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide56.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide56.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                                <b> do it yourself</b>
<br>
    Do the same in your Poisson model
<br>
    The ML-estimate of the constant when you have no explanatory variables is
    ln(mean)
<br>
</pre>
<pre><a href="#app16">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide55.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide57.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide57.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                                <b> allow weights</b>
<br>
    It would be nice to allow weights
<br>
</pre>
</div><pre class="output">
<br>
<b>. program drop _all</b>
<br>
<b>. </b>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: void logiteval(transmorphic M, real rowvector b, real colvector lnf)</b>
<b>&gt; {</b>
<b>&gt;     real colvector xb</b>
<b>&gt;     real colvector y</b>
<b>&gt;     </b>
<b>&gt;     xb = moptimize_util_xb(M, b, 1)</b>
<b>&gt;     y  = moptimize_util_depvar(M,1)</b>
<b>&gt;     </b>
<b>&gt;     lnf = y:*ln(invlogit(xb)) + (1:-y):*ln(invlogit(-xb)) </b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void logitwork(string scalar depvar, string scalar indepvars)</b>
<b>&gt; {</b>
<b>&gt;     transmorphic M</b>
<b>&gt;     M = moptimize_init()</b>
<b>&gt;     moptimize_init_evaluatortype(M, "lf")</b>
<b>&gt;     moptimize_init_evaluator(M, &amp;logiteval())</b>
<b>&gt;     moptimize_init_touse(M, st_local("touse"))</b>
<b>&gt;     moptimize_init_ndepvars(M,1)</b>
<b>&gt;     moptimize_init_depvar(M, 1, depvar)</b>
<b>&gt;     moptimize_init_eq_indepvars(M,1,indepvars) </b>
<b>&gt;     if (st_local("weight") != "") {</b>
<b>&gt;         moptimize_init_weighttype(M, st_local("weight"))</b>
<b>&gt;         moptimize_init_weight(M, st_local("exp"))</b>
<b>&gt;     }</b>
<b>&gt;     moptimize_init_valueid(M, "log likelihood")</b>
<b>&gt;     moptimize_init_eq_coefs(M,1,st_matrix("r(b0)"))</b>
<b>&gt;     moptimize_init_search(M, "off")</b>
<b>&gt;     moptimize(M)</b>
<b>&gt;     moptimize_result_display(M)</b>
<b>&gt;     moptimize_result_post(M)</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
<b>. program define startval, rclass</b>
  1<b>.     syntax varname [if] [fweight pweight iweight/], k(integer) </b>
  2<b>.     </b>
<b>.     tempname b0</b>
  3<b>.     matrix `b0' = J(1, `k', 0)</b>
  4<b>.     </b>
<b>.     if "`weight'" != "" local wgt [`weight' = `exp']</b>
  5<b>.     if "`weight'" == "pweight" local wgt [aweight = `exp']</b>
  6<b>.     marksample touse</b>
  7<b>.     sum `varlist' if `touse' `wgt', meanonly</b>
  8<b>.     matrix `b0'[1,`k'] = logit(r(mean))</b>
  9<b>.     return matrix b0 = `b0'</b>
 10<b>. </b>
<b>. end</b>
<br>
<b>. </b>
<b>. program define my_logit, eclass</b>
  1<b>.     version 16</b>
  2<b>.     syntax varlist(fv ts) [if] [in] [fweight pweight iweight/] </b>
  3<b>. </b>
<b>.     if "`weight'" != "" local wgt [`weight' = `exp']</b>
  4<b>.     marksample touse</b>
  5<b>.     </b>
<b>.     _rmcoll `varlist' if `touse' `wgt' , expand ///</b>
<b>&gt;         logit touse(`touse')       // options specific to logit (detect perfe</b>
<b>&gt; ct predictions)</b>
  6<b>.     </b>
<b>.     local varlist `r(varlist)'</b>
  7<b>.     gettoken y x : varlist</b>
  8<b>.     _fv_check_depvar `y'</b>
  9<b>.     </b>
<b>.     local k : word count `x'</b>
 10<b>.     local k = `k' + 1 // the constant</b>
 11<b>.         </b>
<b>.     startval `y' if `touse' `wgt', k(`k') `constant'</b>
 12<b>.     </b>
<b>.     mata logitwork("`y'", "`x'")</b>
 13<b>. end</b>
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide56.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide58.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide58.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                                <b> do it yourself</b>
<br>
    Do the same for your Poisson model
<br>
</pre>
<pre><a href="#app17">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide57.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide59.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide59.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                               <b> Make an ado file</b>
<br>
    Now we can clean our code up, and save it as an .ado file
<br>
</pre>
</div><pre class="code">
<code>*! version 1.0.0 MLB 06Oct2021</code>
<code>program define my_logit, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(fv ts) [if] [in] [fweight pweight iweight/] </code>
<code></code>
<code>    if "`weight'" != "" local wgt [`weight' = `exp']</code>
<code>    marksample touse</code>
<code>    </code>
<code>    _rmcoll `varlist' if `touse' `wgt' , expand ///</code>
<code>        logit touse(`touse')       // options specific to logit (detect perfect predictions)</code>
<code>    </code>
<code>    local varlist `r(varlist)'</code>
<code>    gettoken y x : varlist</code>
<code>    _fv_check_depvar `y'</code>
<code>    </code>
<code>    local k : word count `x'</code>
<code>    local k = `k' + 1 // the constant</code>
<code>        </code>
<code>    startval `y' if `touse' `wgt', k(`k') `constant'</code>
<code>    mata logitwork("`y'", "`x'")</code>
<code>end</code>
<code></code>
<code>program define startval, rclass</code>
<code>    syntax varname [if] [fweight pweight iweight/], k(integer) </code>
<code>    </code>
<code>    tempname b0</code>
<code>    matrix `b0' = J(1, `k', 0)</code>
<code>    </code>
<code>    if "`weight'" != "" local wgt [`weight' = `exp']</code>
<code>    if "`weight'" == "pweight" local wgt [aweight = `exp']</code>
<code>    marksample touse</code>
<code>    sum `varlist' if `touse' `wgt', meanonly</code>
<code>    matrix `b0'[1,`k'] = logit(r(mean))</code>
<code>    return matrix b0 = `b0'</code>
<code>end</code>
<code></code>
<code></code>
<code>mata:</code>
<code>mata set matastrict on</code>
<code></code>
<code>void logiteval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*ln(invlogit(xb)) + (1:-y):*ln(invlogit(-xb)) </code>
<code>}</code>
<code></code>
<code>void logitwork(string scalar depvar, string scalar indepvars)</code>
<code>{</code>
<code>	transmorphic M</code>
<code>    M = moptimize_init()</code>
<code>    moptimize_init_evaluatortype(M, "lf")</code>
<code>    moptimize_init_evaluator(M, &logiteval())</code>
<code>    moptimize_init_touse(M, st_local("touse"))</code>
<code>    moptimize_init_ndepvars(M,1)</code>
<code>    moptimize_init_depvar(M, 1, depvar)</code>
<code>    moptimize_init_eq_indepvars(M,1,indepvars) </code>
<code>   </code>
<code>    if (st_local("weight") != "") {</code>
<code>     	moptimize_init_weighttype(M, st_local("weight"))</code>
<code>        moptimize_init_weight(M, st_local("exp"))</code>
<code>    }</code>
<code>    moptimize_init_valueid(M, "log likelihood")</code>
<code>    moptimize_init_eq_coefs(M,1,st_matrix("r(b0)"))</code>
<code>    moptimize_init_search(M, "off")</code>
<code>    moptimize(M)</code>
<code>    moptimize_result_display(M)</code>
<code>    moptimize_result_post(M)</code>
<code>}</code>
<code></code>
<code>end</code>
</pre>
<div class="txt"><pre>
 
</pre>
</div><pre class="output">
<br>
<b>. sysuse auto, clear</b>
(1978 automobile data)
<br>
<b>. sum price</b>
<br>
    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
       price |<b>         74    6165.257    2949.496       3291      15906</b>
<br>
<b>. gen expensive = price &gt; r(mean) if price &lt; .</b>
<br>
<b>. my_logit foreign i.expensive weight</b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b>-24.117046</b>  
Iteration 2:   log likelihood = <b>-21.896816</b>  
Iteration 3:   log likelihood = <b> -21.76913</b>  
Iteration 4:   log likelihood = <b>-21.768986</b>  
Iteration 5:   log likelihood = <b>-21.768986</b>  
<br>
                                                            Number of obs = <b>74</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
 1.expensive |<b>    3.79774   1.291705     2.94   0.003     1.266044    6.329436</b>
      weight |<b>  -.0037119   .0008779    -4.23   0.000    -.0054326   -.0019912</b>
       _cons |<b>   8.255436    2.06364     4.00   0.000     4.210776     12.3001</b>
------------------------------------------------------------------------------
<br>
<b>. logit foreign i.expensive weight </b>
<br>
Iteration 0:   log likelihood = <b> -45.03321</b>  
Iteration 1:   log likelihood = <b>-24.117046</b>  
Iteration 2:   log likelihood = <b>-21.897931</b>  
Iteration 3:   log likelihood = <b>-21.769135</b>  
Iteration 4:   log likelihood = <b>-21.768986</b>  
Iteration 5:   log likelihood = <b>-21.768986</b>  
<br>
Logistic regression                                     Number of obs = <b>    74</b>
                                                        LR chi2(<b>2</b>)    = <b> 46.53</b>
                                                        Prob &gt; chi2   = <b>0.0000</b>
Log likelihood = <b>-21.768986</b>                             Pseudo R2     = <b>0.5166</b>
<br>
------------------------------------------------------------------------------
     foreign | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
 1.expensive |<b>    3.79774   1.291705     2.94   0.003     1.266044    6.329436</b>
      weight |<b>  -.0037119   .0008779    -4.23   0.000    -.0054326   -.0019912</b>
       _cons |<b>   8.255436    2.06364     4.00   0.000     4.210776     12.3001</b>
------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide58.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide60.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide60.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Maximum likelihood: logit and Poisson regression
-------------------------------------------------------------------------------
<br>
                                <b> do it yourself</b>
<br>
    Do the same for your Poisson regression
<br>
</pre>
<pre><a href="#app18">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide59.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide61.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide61.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Certification
-------------------------------------------------------------------------------
<br>
                             <b> Certification script</b>
<br>
    A certification script is just a .do file
<br>
    It checks if things you think should be true are actually true.
<br>
    If you make it public, then that helps build confidence in the quality of
    your program.
<br>
    At least, you are open about what you have checked and what you have not
    checked
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide60.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide62.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide62.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Functions in Mata</b> -- Certification
-------------------------------------------------------------------------------
<br>
                      <b> What is in a certification script</b>
<br>
    For estimation commands a minimalist certification script that is quick
    to write and can pick up a lot of bugs before you go public would
    consider:
<br>
        Often there are special cases of your model, where you know what the
        solution is.  In our cases, that would be the model without
        covariates.
<br>
        You can "manually" implement an <b>if</b> condition by just dropping the
        unwanted observations. Adding an <b>if</b> condition and the manual way,
        should yield the exact same results
<br>
        You can "manually" implement <b>fweight</b>s by <b>expanding</b> the dataset.
        Adding an <b>fweight</b>s and the manual way, should yield the exact same
        results
<br>
    A more complete certification script would also certify the (Mata)
    subroutines
<br>
    You can read more on certification scripts in (Gould 2001; Buis 2014) and
    cscript
<br>
    A basic certification script for the <b>my_logit</b> command is here:
<br>
</pre>
</div><pre class="code">
<code>cd "d:\mijn documenten\onderwijs\konstanz\stata\mata\source"</code>
<code>cscript</code>
<code></code>
<code>// known to be true results</code>
<code>sysuse auto, clear</code>
<code>my_logit foreign</code>
<code>sum foreign, meanonly</code>
<code>assert reldif(_b[_cons], logit(r(mean))) &lt; 1e-8</code>
<code></code>
<code>// if condition</code>
<code>sysuse auto, clear</code>
<code>keep if rep78 &lt; 5</code>
<code>my_logit foreign weight</code>
<code>storedresults save mustbetrue e()</code>
<code></code>
<code>sysuse auto, clear</code>
<code>my_logit foreign weight if rep78 &lt; 5</code>
<code>storedresults compare mustbetrue e()</code>
<code></code>
<code>storedresults drop mustbetrue</code>
<code></code>
<code>// weights</code>
<code>sysuse auto, clear</code>
<code>expand rep78</code>
<code>my_logit foreign weight</code>
<code>storedresults save mustbetrue e()</code>
<code></code>
<code>sysuse auto, clear</code>
<code>replace rep78 = 1 if rep78 == .</code>
<code>my_logit foreign weight [fweight=rep78]</code>
<code>storedresults compare mustbetrue e(), exclude(matrices: ml_scale ml_h gradient ilog) tolerance(1e-8)</code>
<code></code>
<code>storedresults drop mustbetrue</code>
<code></code>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide61.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide63.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide63.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- Pointers
-------------------------------------------------------------------------------
<br>
                              <b> What is a pointer</b>
<br>
    Variables and functions are stored in memory
<br>
    These objects have an address, so the computer is able to find these.
<br>
    These addresses are just a number
<br>
    This is what a <b>pointer</b> is
<br>
    If we type <b>p = &amp;x</b>, then p is a pointer, which points to x
<br>
    If we type <b>*p</b>, then we refer to contents of that address, or we
    derefernce p
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: x = 1, 2 \ 3, 4</b>
<br>
<b>: p = &amp;x</b>
<br>
<b>: p</b>
<b>  0x356d5110</b>
<br>
<b>: *p</b>
<b>       </b>1   2
    +---------+
  1 |  <b>1   2</b>  |
  2 |  <b>3   4</b>  |
    +---------+
<br>
<b>: (*p)[1,2]</b>
<b>  2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide62.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide64.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide64.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- Pointers
-------------------------------------------------------------------------------
<br>
                        <b> Passing functions to functions</b>
<br>
    A common application of pointers is to pass a function to another
    function.
<br>
    A pointer can point to functions as well as data
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: </b>
<b>: void greetings(string scalar who)</b>
<b>&gt; {</b>
<b>&gt;     printf("Hello " + who)</b>
<b>&gt; }   </b>
<br>
<b>: </b>
<b>: p = &amp;greetings()</b>
<br>
<b>: </b>
<b>: (*p)("BIBB")</b>
<b>Hello BIBB</b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    We have seen an application in <b>moptimize</b>
<br>
    We created a function <b>logiteval()</b> that computes our log likelihood, and
    we needed to pass that on to <b>moptimize</b>, which we did with the line:
<br>
        <b>moptimize_init_evaluator(M, &amp;logiteval())</b>
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide63.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide65.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide65.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- Pointers
-------------------------------------------------------------------------------
<br>
        <b> Try it yourself: approximating a function with a linear spline</b>
<br>
    We are writing a program to approximate a function with a set of linear
    splines
<br>
    We need to find the knots
<br>
        We start with a lower and upper bound
<br>
        we look at the middle, and see if the approximation there is good
        enough
<br>
        If it is not, we add a knots
<br>
        We continue adding knots till the approximation is good enough
<br>
    Here is a first attempt:
<br>
</pre>
</div><pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>// the function we want to apprximate</code>
<code>real scalar curve(real scalar mu)</code>
<code>{</code>
<code>	real colvector y, lnL</code>
<code>	y = 0 \ 5 \ 2 \ 2 \ 4 \ 8 \ 1</code>
<code>    lnL = y:*ln(mu) :- mu :- lnfactorial(y)</code>
<code>	return(sum(lnL))</code>
<code>}</code>
<code></code>
<code>// the approximation</code>
<code>real matrix find_knots(real scalar lb, real scalar ub, real scalar tol, real scalar maxiter)</code>
<code>{</code>
<code>	real matrix res </code>
<code>    real rowvector newknot</code>
<code>    real scalar i,j</code>
<code>    </code>
<code>    res = init_knots(lb, ub)</code>
<code>    </code>
<code>    i = 1</code>
<code>    j= 0</code>
<code>    while (i &lt; rows(res) & j &lt; maxiter) {</code>
<code>    	j++</code>
<code>    	newknot = check_knot(res[i,.], res[i+1,.], tol)</code>
<code>        if (newknot != J(1,0,.)) {</code>
<code>            res = res[|1,1 \ i, 2|] \ newknot \ res[|i+1,1 \ .,2 |]</code>
<code>        }</code>
<code>        else {</code>
<code>        	i++</code>
<code>        }</code>
<code>    }</code>
<code>    if (j==maxiter) {</code>
<code>        exit(error(430))</code>
<code>    }</code>
<code>    return(res)</code>
<code>}</code>
<code></code>
<code>real matrix init_knots(real scalar lb, real scalar ub)</code>
<code>{</code>
<code>	real matrix res</code>
<code>    </code>
<code>    res = J(2,2,.)</code>
<code>    res[.,1] = lb \ ub</code>
<code>    res[1,2] = curve(lb)</code>
<code>    res[2,2] = curve(ub)</code>
<code>    </code>
<code>    return(res)</code>
<code>}</code>
<code></code>
<code>real rowvector check_knot(rowvector lk, rowvector uk, real scalar tol)</code>
<code>{</code>
<code>	real scalar est, x, ref</code>
<code></code>
<code>    est = interp(lk[2], uk[2])</code>
<code>    x   = interp(lk[1], uk[1])</code>
<code>    ref = curve(x)</code>
<code>    if (reldif(est,ref) &gt; tol) {</code>
<code>    	return((x,ref))</code>
<code>    }</code>
<code>    else{</code>
<code>    	return(J(1,0,.))</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>real scalar interp(real scalar lv, real scalar uv) </code>
<code>{</code>
<code>	return(lv + (uv-lv)/2)</code>
<code>}</code>
<code></code>
<code>real scalar eval_spline(real matrix sp, real scalar x)</code>
<code>{</code>
<code>	real scalar i, frac</code>
<code>    </code>
<code>    if (x == sp[rows(sp),1]) return(sp[rows(sp),2])</code>
<code>	</code>
<code>    i = find_x(sp,x)</code>
<code>    </code>
<code>    frac = (x - sp[i,1]) / (sp[i+1,1] - sp[i,1])</code>
<code>    </code>
<code>    return(sp[i,2] + frac* (sp[i+1,2] - sp[i,2]))</code>
<code>}</code>
<code></code>
<code>real scalar find_x(real matrix sp, real scalar x) </code>
<code>{</code>
<code>	real scalar i</code>
<code>    </code>
<code>    for(i=1; i &lt;= rows(sp); i++) {</code>
<code>    	if (sp[i,1] &gt;= x) break</code>
<code>    }</code>
<code>    </code>
<code>    if (i == rows(sp)) {</code>
<code>    	printf("x is out of range of sp")</code>
<code>    	exit(198)</code>
<code>    }</code>
<code>    </code>
<code>    return(i)</code>
<code>    </code>
<code>}</code>
<code>end</code>
<code>// example use</code>
<code>drop _all</code>
<code>mata:</code>
<code>sp = find_knots(1e-5,10,1e-3,1000)</code>
<code></code>
<code>res = J(80,3,.)</code>
<code>for(i=1; i&lt;=80; i++) {</code>
<code>	j=i/10</code>
<code>    res[i,.] = (j, eval_spline(sp,j), curve(j))</code>
<code>}</code>
<code></code>
<code>nobs = st_nobs()</code>
<code>if (nobs &lt; 80) st_addobs(80-nobs)</code>
<code></code>
<code>idx = st_addvar("double", ("x","aprox", "actual"))</code>
<code>st_store(.,idx, res)</code>
<code></code>
<code>end</code>
<code></code>
<code>twoway line aprox actual x</code>
</pre>
<div class="txt"><pre>
<br>
    The function we want to approximate is now hard coded in our program. We
    could make this more general with pointers
<br>
    Do so
<br>
</pre>
<pre><a href="#app19">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide64.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide66.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide66.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- Pointers
-------------------------------------------------------------------------------
<br>
               <b> Collecting different things under a single name</b>
<br>
    You can make a matrix of pointers
<br>
    these pointers can point to very differnt types of objects
<br>
    We will later see more convient ways of collecting different types of
    objects, but occationally using a matrix of pointers can be useful.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: collection = J(3,1,NULL)</b>
<br>
<b>: collection[1] = &amp;(1,5,2,5,3)</b>
<br>
<b>: collection[2] = &amp;( "Hallo, meneer de Uil," \</b>
<b>&gt;                    "waar breng je ons naar toe?" \</b>
<b>&gt;                    "Naar Fabeltjesland?" \</b>
<b>&gt;                    "Eh, ja, naar Fabeltjesland!" \</b>
<b>&gt;                    "En lees je ons dan voor" \</b>
<b>&gt;                    "uit de Fabeltjeskrant?" \</b>
<b>&gt;                    "Ja, ja, uit de Fabeltjeskrant!" \</b>
<b>&gt;                    "Want daarin staat precies vermeld" \</b>
<b>&gt;                    "hoe het met de dieren is gesteld." \</b>
<b>&gt;                    "Echt waar? " \</b>
<b>&gt;                    "Echt waar!" \</b>
<b>&gt;                    "Echt waar, meneer de Uil?" \</b>
<b>&gt;                    "Want dieren zijn precies als mensen" \</b>
<b>&gt;                    "Met dezelfde mensen-wensen" \</b>
<b>&gt;                    "En dezelfde mensen-streken" \</b>
<b>&gt;                    "Dat staan allemaal in de krant van Fabeltjesland," \</b>
<b>&gt;                    "van Fabeltjesland" \</b>
<b>&gt;                    "De faaabeltjeskrant" )</b>
<br>
<b>:                    </b>
<b>: void greetings(string scalar who)</b>
<b>&gt; {</b>
<b>&gt;     printf("Hello " + who)</b>
<b>&gt; }                  </b>
<br>
<b>:                    </b>
<b>: collection[3] = &amp;greetings()</b>
<br>
<b>: </b>
<b>: *collection[1]</b>
<b>       </b>1   2   3   4   5
    +---------------------+
  1 |  <b>1   5   2   5   3</b>  |
    +---------------------+
<br>
<b>: *collection[2]</b>
<b>        </b>                                                1
     +-----------------------------------------------------+
   1 |  <b>                            Hallo, meneer de Uil,</b>  |
   2 |  <b>                      waar breng je ons naar toe?</b>  |
   3 |  <b>                              Naar Fabeltjesland?</b>  |
   4 |  <b>                      Eh, ja, naar Fabeltjesland!</b>  |
   5 |  <b>                          En lees je ons dan voor</b>  |
   6 |  <b>                           uit de Fabeltjeskrant?</b>  |
   7 |  <b>                   Ja, ja, uit de Fabeltjeskrant!</b>  |
   8 |  <b>                Want daarin staat precies vermeld</b>  |
   9 |  <b>                hoe het met de dieren is gesteld.</b>  |
  10 |  <b>                                      Echt waar? </b>  |
  11 |  <b>                                       Echt waar!</b>  |
  12 |  <b>                        Echt waar, meneer de Uil?</b>  |
  13 |  <b>              Want dieren zijn precies als mensen</b>  |
  14 |  <b>                       Met dezelfde mensen-wensen</b>  |
  15 |  <b>                       En dezelfde mensen-streken</b>  |
  16 |  <b>Dat staan allemaal in de krant van Fabeltjesland,</b>  |
  17 |  <b>                                van Fabeltjesland</b>  |
  18 |  <b>                              De faaabeltjeskrant</b>  |
     +-----------------------------------------------------+
<br>
<b>: (*collection[3])("world")</b>
<b>Hello world</b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
<b>. </b>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide65.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide67.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide67.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- Pointers
-------------------------------------------------------------------------------
<br>
                 <b> Using pointers to create an irregular array</b>
<br>
    A special case of this would be an irregular array
<br>
    A matrix is a regular array: each row has the same number of columns
<br>
    An irregular array would allow each row to have a different number of
    columns
<br>
    Consider the example below where we have data on the alliance structure
    of tribes in the Eastern Central Highlands of New Guinea in the 1950's
<br>
</pre>
</div><pre class="output">
<br>
<b>. use alliance.dta, clear</b>
(Gahuku–Gama alliance structure)
<br>
<b>. notes</b>
<br>
<b>_dta:</b>
  1.  Source: Read, Kenneth E. (1954) Cultures of the central highlands, New
      Guinea. Southwestern Journal of Anthropology, 10(1), pp. 1-43.
<br>
<b>. list in 1/10</b>
<br>
     +--------------------+
     | <b>ego   alter   sign </b>|
     |--------------------|
  1. | <b>  1       2      1 </b>|
  2. | <b>  1       3     -1 </b>|
  3. | <b>  2       3     -1 </b>|
  4. | <b>  1       4     -1 </b>|
  5. | <b>  3       4      1 </b>|
     |--------------------|
  6. | <b>  1       5     -1 </b>|
  7. | <b>  2       5     -1 </b>|
  8. | <b>  1       6     -1 </b>|
  9. | <b>  2       6     -1 </b>|
 10. | <b>  3       6      1 </b>|
     +--------------------+
<br>
</pre>
<div class="txt"><pre>
    Tribe 1 is a friend of tribe 2, but an enemy of tribe 3, etc.
<br>
    We don't have a line in the data that says that tribe 2 is a friend of
    tribe 1.  That is implicit.
<br>
    If we were programming a network analysis where we need to repeatedly
    find all the friends of tribe i, then this would be inconvenient (slow)
<br>
    We could instead reorganize the data in an irregular array (not every
    tribe has the same number of friends)
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: data = st_data(.,"ego alter sign")</b>
<br>
<b>: </b>
<b>: friends = J(16,1,&amp;J(1,0,.))</b>
<br>
<b>: enemies = J(16,1,&amp;J(1,0,.))</b>
<br>
<b>: for(i=1; i&lt;=rows(data); i++) {</b>
<b>&gt;     if (data[i,3] == 1) {</b>
<b>&gt;         friends[data[i,1]] = &amp;(*friends[data[i,1]], data[i,2])</b>
<b>&gt;         friends[data[i,2]] = &amp;(*friends[data[i,2]], data[i,1])</b>
<b>&gt;     }</b>
<b>&gt;     else {</b>
<b>&gt;         enemies[data[i,1]] = &amp;(*enemies[data[i,1]], data[i,2])</b>
<b>&gt;         enemies[data[i,2]] = &amp;(*enemies[data[i,2]], data[i,1])</b>
<b>&gt;     }</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: *enemies[1]</b>
<b>       </b> 1    2    3    4    5
    +--------------------------+
  1 |  <b> 3    4    5    6   12</b>  |
    +--------------------------+
<br>
<b>: *friends[1]</b>
<b>       </b> 1    2    3
    +----------------+
  1 |  <b> 2   15   16</b>  |
    +----------------+
<br>
<b>: *enemies[16]</b>
<b>       </b> 1    2    3    4    5    6
    +-------------------------------+
  1 |  <b> 5    6   11   12   13   14</b>  |
    +-------------------------------+
<br>
<b>: *friends[16]</b>
<b>       </b> 1    2    3
    +----------------+
  1 |  <b> 1    2   15</b>  |
    +----------------+
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide66.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide68.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide68.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- Pointers
-------------------------------------------------------------------------------
<br>
                          <b> Try it yourself: 3D array</b>
<br>
    Say we observed a matrix at three points in time.
<br>
    Our results are:
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: A1 = 2, 5, 3 \</b>
<b>&gt;      2, 3, 9</b>
<br>
<b>: </b>
<b>: A2 = 4, 6, 2 \</b>
<b>&gt;      1, 4, 2 </b>
<br>
<b>:       </b>
<b>: A3 = 6, 2, 7 \</b>
<b>&gt;      2, 5, 1       </b>
<br>
<b>: end     </b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    We want to store them in a single object, using pointers
<br>
    extract from that object the value for t=2, row=2, col=3
<br>
</pre>
<pre><a href="#app20">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide67.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide69.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide69.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- associative array
-------------------------------------------------------------------------------
<br>
                         <b> What is an associative array</b>
<br>
    In a matrix the rows and columns are numbered, and we refer to the cells
    by these row and column numbers
<br>
    What if we could use names instead of numbers, and what if we could store
    anything we want in the cells?
<br>
    That is an <b>associative array</b>
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide68.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide70.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide70.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- associative array
-------------------------------------------------------------------------------
<br>
                       <b> Example: a bibliography in Mata</b>
<br>
    Say we want to store a bibliography in Mata
<br>
        Each article or book has a unique identifier, the key
<br>
        For each key we want to store when applicable: the author(s), the
        year, the title, the journal, the pages, the publisher
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: bib = AssociativeArray()</b>
<br>
<b>: bib.reinit("string",2)</b>
<br>
<b>: </b>
<b>: bib.put(("gould18","author"), "William W. Gould")</b>
<br>
<b>: bib.put(("gould18","year"), 2018)</b>
<br>
<b>: bib.put(("gould18","title"), "The Mata Book: A Book for Serious Programmers a</b>
<b>&gt; nd Those Who Want to Be")</b>
<br>
<b>: bib.put(("gould18","publisher"), "Stata Press")</b>
<br>
<b>: bib.put(("gould18","address"), "College Station, TX")</b>
<br>
<b>: </b>
<b>: bib.put(("buis14","author"), "Maarten L. Buis")</b>
<br>
<b>: bib.put(("buis14","year"), 2014)</b>
<br>
<b>: bib.put(("buis14","title"), "Stata tip 120: Certifying subroutines")</b>
<br>
<b>: bib.put(("buis14","journal"), "The Stata Journal")</b>
<br>
<b>: bib.put(("buis14","volume"), 14)</b>
<br>
<b>: bib.put(("buis14","number"), 2)</b>
<br>
<b>: bib.put(("buis14","pages"), "449-450")</b>
<br>
<b>: </b>
<b>: bib.get(("gould18","title"))</b>
<b>  The Mata Book: A Book for Serious Programmers and Those Who Want to Be</b>
<br>
<b>: </b>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    In the project we will do in the next section we will make extensive use
    of associative arrays
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide69.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide71.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide71.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- struct
-------------------------------------------------------------------------------
<br>
                               <b> What is a struct</b>
<br>
    A <b>struct</b> is another way of storing multiple things in a single object.
<br>
    The difference is that what it contains and their names have to be
    declared beforehand.
<br>
    This makes it quicker to store and retrieve things and there is automatic
    error checking, but is less flexible.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear </b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: struct mystruct {</b>
<b>&gt;     real scalar x, y</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void main_func(real scalar x, real scalar y)</b>
<b>&gt; {</b>
<b>&gt;     struct mystruct scalar data</b>
<b>&gt;     </b>
<b>&gt;     data.x = x</b>
<b>&gt;     data.y = y</b>
<b>&gt;     </b>
<b>&gt;     subroutine(data)</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: real scalar subroutine(struct mystruct scalar data)</b>
<b>&gt; {</b>
<b>&gt;     return(data.x+data.y)</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: main_func(1,5)</b>
<b>  6</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    I use <b>struct</b>s in larger projects with many subroutines and I have a large
    amount of information to move between those routines.
<br>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide70.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide72.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide72.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- struct
-------------------------------------------------------------------------------
<br>
        <b> Try it yourself: approximating a function with a linear spline</b>
<br>
    Revisit our linear spline program. We can package lb, ub, tol, maxiter,
    p, and res in a <b>struct</b> and pass those between subroutines of
    <b>find_knots()</b>.
<br>
</pre>
<pre><a href="#app21">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide71.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide73.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide73.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- class
-------------------------------------------------------------------------------
<br>
                               <b> What is a class</b>
<br>
    A <b>class</b> is a <b>struct</b> that can also contain functions.  These functions
    have access to all the data in that class.
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear </b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: class myclass {</b>
<b>&gt;     real scalar x, y</b>
<b>&gt;     real scalar sum()</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: </b>
<b>: real scalar myclass::sum()</b>
<b>&gt; {</b>
<b>&gt;     return(x+y)</b>
<b>&gt; }</b>
<br>
<b>: a = myclass()</b>
<br>
<b>: a.x=3</b>
<br>
<b>: a.y=2</b>
<br>
<b>: a.sum()</b>
<b>  5</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
    I use classes when I have lots of subroutines
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide72.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide74.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide74.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- class
-------------------------------------------------------------------------------
<br>
                                   <b> 3D array</b>
<br>
    Previously we made a three dimensional array using pointers.
<br>
    Subscripting our array is however awkward, as we subscript in two
    different places: once at the array of pointer and once inside the matrix
    to which the pointer points.
<br>
    If I were to use such an array in my programs, then I would write a
    wrapper around it using a class
<br>
 
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: class threeD{</b>
<b>&gt;     private:</b>
<b>&gt;         pointer (real matrix) colvector data</b>
<b>&gt;         real                  scalar    rdim, cdim, zdim, setup</b>
<b>&gt;         void                            setup()</b>
<b>&gt;         void                            new()</b>
<b>&gt;         void                            isposint()</b>
<b>&gt;     </b>
<b>&gt;     public: </b>
<b>&gt;         transmorphic                    rdim()</b>
<b>&gt;         transmorphic                    cdim()</b>
<b>&gt;         transmorphic                    zdim()</b>
<b>&gt;         void                            put()</b>
<b>&gt;         real matrix                     get()</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void threeD::new()</b>
<b>&gt; {</b>
<b>&gt;     setup = 0</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: void threeD::isposint(real matrix tocheck)</b>
<b>&gt; {</b>
<b>&gt;     if (floor(tocheck)!= tocheck | any(tocheck :&lt;= 0)) {</b>
<b>&gt;         _error(3300, "argument must be positive integers")</b>
<b>&gt;     }</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: transmorphic threeD::rdim(| real scalar val)</b>
<b>&gt; {</b>
<b>&gt;     if (args() == 1) {</b>
<b>&gt;         isposint(val)</b>
<b>&gt;         rdim = val</b>
<b>&gt;     }</b>
<b>&gt;     else {</b>
<b>&gt;         return(rdim)</b>
<b>&gt;     }</b>
<b>&gt; }</b>
<br>
<b>: transmorphic threeD::cdim(| real scalar val)</b>
<b>&gt; {</b>
<b>&gt;     if (args() == 1) {</b>
<b>&gt;         isposint(val)</b>
<b>&gt;         cdim = val</b>
<b>&gt;     }</b>
<b>&gt;     else {</b>
<b>&gt;         return(cdim)</b>
<b>&gt;     }</b>
<b>&gt; }</b>
<br>
<b>: transmorphic threeD::zdim(| real scalar val)</b>
<b>&gt; {</b>
<b>&gt;     if (args() == 1) {</b>
<b>&gt;         isposint(val)</b>
<b>&gt;         zdim = val</b>
<b>&gt;     }</b>
<b>&gt;     else {</b>
<b>&gt;         return(zdim)</b>
<b>&gt;     }</b>
<b>&gt; }</b>
<br>
<b>: void threeD::setup()</b>
<b>&gt; {</b>
<b>&gt;     real scalar i</b>
<b>&gt;     </b>
<b>&gt;     if (setup) return</b>
<b>&gt;     if (rdim==. | cdim==. | zdim==.) {</b>
<b>&gt;         _error(30000, "rdim, cdim, and zdim need to be set first")</b>
<b>&gt;     }</b>
<b>&gt;     data = J(zdim,1,NULL)</b>
<b>&gt;     for(i=1; i&lt;= zdim; i++) {</b>
<b>&gt;         data[i] = &amp;J(rdim,cdim,.)</b>
<b>&gt;     }</b>
<b>&gt;     setup = 1</b>
<b>&gt; }</b>
<br>
<b>: void threeD::put(real rowvector key, real matrix val)</b>
<b>&gt; {</b>
<b>&gt;     real scalar r, c, z</b>
<b>&gt;     real matrix toput</b>
<b>&gt;     </b>
<b>&gt;     if (!setup) setup()</b>
<b>&gt;     </b>
<b>&gt;     r = key[1]</b>
<b>&gt;     c = key[2]</b>
<b>&gt;     z = key[3]</b>
<b>&gt;     if ( z == . ) _error(3000, "z cannot be missing")</b>
<b>&gt; </b>
<b>&gt;     toput = *data[z]</b>
<b>&gt;     toput[r,c] = val</b>
<b>&gt;     data[z] = &amp;toput</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: real matrix threeD::get(real rowvector key)</b>
<b>&gt; {</b>
<b>&gt;     real scalar r, c, z</b>
<b>&gt;     real matrix toget</b>
<b>&gt;     </b>
<b>&gt;     if (!setup) return(J(0,0,.))</b>
<b>&gt;     </b>
<b>&gt;     r = key[1]</b>
<b>&gt;     c = key[2]</b>
<b>&gt;     z = key[3]</b>
<b>&gt;     if ( z == . ) _error(3000, "z cannot be missing")</b>
<b>&gt; </b>
<b>&gt;     toget = *data[z]</b>
<b>&gt;     return(toget[r,c])</b>
<b>&gt; }</b>
<br>
<b>: </b>
<b>: //intended use</b>
<b>: data = threeD()</b>
<br>
<b>: data.rdim(3)</b>
<br>
<b>: data.cdim(2)</b>
<br>
<b>: data.zdim(4)</b>
<br>
<b>: </b>
<b>: A1 = 3,2 \</b>
<b>&gt;      3,1 \</b>
<b>&gt;      5,2</b>
<br>
<b>: </b>
<b>: data.put((.,.,1), A1)</b>
<br>
<b>: data.put((1,1,2), 2)</b>
<br>
<b>: data.put((1,2,2), 7)</b>
<br>
<b>: </b>
<b>: data.get((.,2,1))</b>
<b>       </b>1
    +-----+
  1 |  <b>2</b>  |
  2 |  <b>1</b>  |
  3 |  <b>2</b>  |
    +-----+
<br>
<b>: data.get((1,1,2))</b>
<b>  2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide73.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide75.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide75.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Advanced data types in Mata</b> -- class
-------------------------------------------------------------------------------
<br>
        <b> Try it yourself: approximating a function with a linear spline</b>
<br>
    Revisit our linear spline program again. We can package the whole thing
    in a class.
<br>
</pre>
<pre><a href="#app22">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide74.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide76.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide76.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b>
-------------------------------------------------------------------------------
<br>
                                   <b> The goal</b>
<br>
    We are going to write a program that receives a text file and returns a
    dataset that contains a list of all words that occured in that file and
    how many times it appeared
<br>
    We will write this using a class
<br>
    The reason we do that, is that we think we want to extend this program
    (text analysis is a huge field)
<br>
    We are writing this program with the goal that it should be easy to
    maintain and extend
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide75.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide77.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide77.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Getting basic working code
-------------------------------------------------------------------------------
<br>
                                <b> Counting words</b>
<br>
    Counting how often each word appears in a document is a classic
    application for an associative array
<br>
    We can use <b>fopen()</b> to open a file
<br>
    A basic start would be:
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata:</b>
------------------------------------------------- mata (type <b>end</b> to exit) -----
<b>: mata clear</b>
<br>
<b>: mata set matastrict on</b>
<br>
<b>: </b>
<b>: hist = AssociativeArray()</b>
<br>
<b>: hist.notfound(0)</b>
<br>
<b>: fh = fopen("spd.txt", "r")</b>
<br>
<b>: </b>
<b>: while ((line=fget(fh))!=J(0,0,"")) {</b>
<b>&gt;     line = tokens(line)</b>
<b>&gt;     for (i=1; i &lt;= cols(line); i++) {</b>
<b>&gt;         freq = hist.get(line[i]) + 1</b>
<b>&gt;         hist.put(line[i], freq)</b>
<b>&gt;     }</b>
<b>&gt; }</b>
<br>
<b>: fclose(fh)</b>
<br>
<b>: </b>
<b>: hist.keys()[1..10,.]</b>
<b>        </b>                          1
     +-------------------------------+
   1 |  <b>                  Menschen.</b>  |
   2 |  <b>Verwaltungsdienstleistungen</b>  |
   3 |  <b>                    wappnen</b>  |
   4 |  <b>                        THW</b>  |
   5 |  <b>               Außenpolitik</b>  |
   6 |  <b>                  Synergien</b>  |
   7 |  <b>               Verteilnetze</b>  |
   8 |  <b>                  Eindruck,</b>  |
   9 |  <b>                    ziviles</b>  |
  10 |  <b>            Insolvenzrecht.</b>  |
     +-------------------------------+
<br>
<b>: hist.get("SPD")</b>
<b>  2</b>
<br>
<b>: end</b>
-------------------------------------------------------------------------------
<br>
</pre>
<div class="txt"><pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide76.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide78.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide78.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Getting basic working code
-------------------------------------------------------------------------------
<br>
                                 <b> punctuation</b>
<br>
    One problem is that punctiation marks are still attached to the words. So
    "Menschen." is counted as a different word as "Menschen"
<br>
    We could make a string with all the punctuation marks we want to remove
    (separated by spaces)
<br>
    use <b>tokens()</b> to turn that into a vector
<br>
    use <b>Mata subinstr()</b> to remove those (i.e. replace it with an empty string
    "")
<br>
</pre>
<pre><a href="#app23">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide77.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide79.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide79.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Getting basic working code
-------------------------------------------------------------------------------
<br>
                               <b> Capital letters</b>
<br>
    The same word can appear starting with and without a capital letter,
    depending on where it is in the sentence
<br>
    These count now as different words
<br>
    The easiest solution is to turn all capital letter into lower case
    letters with the <b>strlower()</b> function
<br>
</pre>
<pre><a href="#app24">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide78.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide80.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide80.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Getting basic working code
-------------------------------------------------------------------------------
<br>
                          <b> Common "meaningless" words</b>
<br>
    There are some words that are very common, but don't interest us
<br>
    For example, "der", "die", und "das"
<br>
</pre>
</div><pre class="output">
<br>
<b>. mata: hist.get("die")</b>
<b>  764</b>
<br>
</pre>
<div class="txt"><pre>
    So we don't want to count those
<br>
    The file "stop_words_german.txt" contains a list of these words
<br>
    We can read that file into Mata using <b>fopen()</b>
<br>
    Put all words in an associative array called stopwords (with a value 1,
    which does not matter)
<br>
    When we count the words from the main file, we first check if that words
    exists in the array stopwords (stopwords.exists()) and only count if that
    is not the case
<br>
</pre>
<pre><a href="#app25">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide79.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide81.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide81.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Getting basic working code
-------------------------------------------------------------------------------
<br>
                        <b> Finding the most common words</b>
<br>
    So what are the most commonly used words in this document?
<br>
    We can extract a vector of words using <b>hist.keys()</b>, which we will call
    words
<br>
    We create a new numeric vector (count) with the same number of rows, loop
    over those and fill these cells with the corresponding counts
<br>
    We use <b>order()</b> to create a permutation vector: The first cell in that
    vector contains the rownumber that cell should be for it to be ordered,
    etc. We will call that vector o
<br>
    We can now order both words and count using <b>words = words[o]</b> and the same
    for count
<br>
    Do this
<br>
</pre>
<pre><a href="#app26">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide80.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide82.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide82.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Getting basic working code
-------------------------------------------------------------------------------
<br>
                         <b> Export the results to Stata</b>
<br>
    Then we create new variables with <b>st_addvar()</b> to add the variables
<br>
    For string variables we need to know the maximum length (in bytes, not
    characters) of the words we want to store. We can get that with the
    <b>strlen()</b> function and <b>max()</b> function
<br>
    For numeric variables we can use <b>st_store()</b> to store the vector in the
    variable
<br>
    For string variables we can use <b>st_sstore()</b>
<br>
    But first we need to make sure there are enough observations in the Stata
    dataset to take all those words. We can count the number of observation
    with <b>st_nobs()</b> and add any extra observations we may need with
    <b>st_addobs()</b>
<br>
</pre>
<pre><a href="#app27">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide81.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide83.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide83.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Turning it into a Mata class
-------------------------------------------------------------------------------
<br>
                               <b> Getting started</b>
<br>
    I usually start with defining the class and naming the variables and
    functions I want it to contain
<br>
    This gives me a roadmap of what I need to do
<br>
    This is where I would start
<br>
<br>
<br>
<b>    class hist_gen {</b>
<b>        string                  scalar    fn_stopwords</b>
<b>        class  AssociativeArray scalar    stopwords</b>
<b>        string                  scalar    fn</b>
<b>        class  AssociativeArray scalar    hist</b>
<b>        string                  rowvector punct</b>
<b>        </b>
<b>        void                              make_hist()       </b>
<b>        void                              setup()           </b>
<b>        void                              parse_stopwords() </b>
<b>        void                              count_words()     </b>
<b>        string                  rowvector parse_line()      </b>
<b>        real                    scalar    valid_word()      </b>
<b>        void                              to_stata()        </b>
<b>    }</b>
<br>
<br>
<b>    void hist_gen::parse_stopwords() </b>
<b>    {</b>
<b>        //line 7-16 of hist05.do</b>
<b>    }</b>
<br>
<b>    void hist_gen::setup() </b>
<b>    {</b>
<b>        parse_stopwords()</b>
<b>        //line 22 of hist05.do  </b>
<b>    }</b>
<br>
<b>    void hist_gen::make_hist()</b>
<b>    {</b>
<b>        setup()</b>
<b>        count_words()</b>
<b>    }   </b>
<br>
<b>    void hist_gen::count_words()</b>
<b>    {</b>
<b>        // line 24-37 of hist05.do</b>
<b>        // but using parse_line() for lines 25-29</b>
<b>        // and use valid_word() for the condition on line 31</b>
<b>    }</b>
<br>
<b>    string rowvector hist_gen::parse_line(string scalar line)</b>
<b>    {</b>
<b>        // line 25-29 of hist05.do</b>
<b>    }</b>
<br>
<b>    real scalar hist_gen::valid_word(string scalar word)</b>
<b>    {</b>
<b>        // line 31 of hist05.do</b>
<b>    }</b>
<br>
<b>    void hist_gen::to_stata()</b>
<b>    {</b>
<b>        // line 39-57 of hist05.do</b>
<b>    }</b>
<b>    end</b>
<br>
<b>    //intended use</b>
<b>    mata:</b>
<b>    hist = hist_gen()</b>
<b>    hist.fn           = "spd.txt"</b>
<b>    hist.fn_stopwords = "stop_words_german.txt"</b>
<b>    hist.punct        = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</b>
<b>    hist.make_hist()</b>
<b>    hist.to_stata()</b>
<b>    end</b>
<br>
<br>
    create a working version of this class
<br>
</pre>
<pre><a href="#app28">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide82.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide84.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide84.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Turning it into a Mata class
-------------------------------------------------------------------------------
<br>
                       <b> Passing parameters to our class</b>
<br>
    For safety you normally would not want users to directly access variables
<br>
    Instead you would want them to go through a function
<br>
<br>
<b>    class hist_gen {</b>
<b>        string                  scalar    fn_stopwords</b>
<b>        class  AssociativeArray scalar    stopwords</b>
<b>        string                  scalar    fn</b>
<b>        class  AssociativeArray scalar    hist</b>
<b>        string                  rowvector punct</b>
<b>        </b>
<b>        transmorphic                      fn_stopwords()</b>
<b>        void                              make_hist()       </b>
<b>        void                              setup()           </b>
<b>        void                              parse_stopwords() </b>
<b>        void                              count_words()     </b>
<b>        string                  rowvector parse_line()      </b>
<b>        real                    scalar    valid_word()      </b>
<b>        void                              to_stata()        </b>
<b>    }</b>
<br>
<b>    transmorphic hist_gen::fn_stopwords(| string scalar val)</b>
<b>    {</b>
<b>        if (args() == 1) {</b>
<b>            // here you can put checks if val is appropriate for that variable</b>
<b>            fn_stopwords = val</b>
<b>        }</b>
<b>        else {</b>
<b>            return(fn_stopwords)</b>
<b>        }</b>
<b>    }</b>
<br>
<br>
    Make functions for <b>fn</b>, and <b>punct</b>
<br>
</pre>
<pre><a href="#app29">(solution)</a></pre>
<pre>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide83.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide85.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide85.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Turning it into a Mata class
-------------------------------------------------------------------------------
<br>
                              <b> private and public</b>
<br>
    Right now user's can still access the variables and all functions.
<br>
    We can prevent that by declaring them private
<br>
    It is generally a good idea to make only the functions the user needs
    public
<br>
<br>
<b>    class hist_gen {</b>
<b>        protected: </b>
<b>            string                  scalar    fn_stopwords</b>
<b>            class  AssociativeArray scalar    stopwords</b>
<b>            string                  scalar    fn</b>
<b>            class  AssociativeArray scalar    hist</b>
<b>            string                  rowvector punct</b>
<br>
<b>            void                              setup()</b>
<b>            void                              parse_stopwords()</b>
<b>            string                  rowvector parse_line()</b>
<b>            real                    scalar    valid_word()</b>
<b>            void                              count_words() </b>
<br>
<b>        public: </b>
<b>            transmorphic                      fn_stopwords()</b>
<b>            transmorphic                      fn()</b>
<b>            transmorphic                      punct()</b>
<b>            void                              make_hist()</b>
<b>            void                              to_stata()</b>
<b>    }</b>
<br>
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide84.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide86.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide86.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- What next
-------------------------------------------------------------------------------
<br>
                                  <b> Next steps</b>
<br>
    write Stata program to interface with that our class
<br>
    Write certification scripts
<br>
    Write the help-files
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide85.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> <a href="#slide87.smcl">&gt;&gt;</a></a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide87.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>Build your own class</b> -- Wrapping up
-------------------------------------------------------------------------------
<br>
                                <b> Useful sources</b>
<br>
    Very useful free websources for learning how to use Mata and program
    commands in Stata are:
<br>
        Bill Gould's Mata, the missing manual presented at the 2010 UK Stata
        Users' Group meeting.
<br>
        David Drukker's Blog Programming an estimation command in Stata
<br>
    If you want to dive deep into Mata, then you cannot go wrong with
<br>
        William W. Gould (2018), <i>The Mata Book: A Book for Serious</i>
        <i>Programmers and Those Who Want to Be</i>.  College Station, TX: The Stata
        Press.
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide86.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> </a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide21.smcl">
<div class="txt"><pre>
-------------------------------------------------------------------------------
<b>digression</b>
-------------------------------------------------------------------------------
<br>
                         <b> macros and scalars in Stata</b>
<br>
    A macro is a shorthand, it is one thing standing for another
<br>
    It can contain anything, but is always a string
<br>
</pre>
</div><pre class="output">
<br>
<b>. local mac "foo"</b>
<br>
<b>. di `mac'</b>
foo not found
r(111);
<br>
</pre>
<div class="txt"><pre>
    I said that the content of a macro is always a string, then why did this
    return an error?
<br>
    The double quotes are there to indicate that this is a string, but they
    are not part of the string.
<br>
    So `mac' contains <i>foo</i> not <i>"foo"</i>
<br>
    So for the second line Stata saw <b>di foo</b>, and since there were no double
    quotes Stata assumed we wanted to look at a variable (or scalar) foo,
    could not find that variable and returned the error message.
<br>
    This will work:
<br>
</pre>
</div><pre class="output">
<br>
<b>. local mac "foo"</b>
<br>
<b>. di "`mac'"</b>
<b>foo</b>
<br>
</pre>
<div class="txt"><pre>
    Because the quotes are stripped, macros may also contain numbers.
<br>
    They are stored as strings, but as soon as Stata replaces the name of the
    macro with its content it will see them as numbers, as there are no
    quotes around them.
<br>
</pre>
</div><pre class="output">
<br>
<b>. local mac 1</b>
<br>
<b>. di `mac'</b>
<b>1</b>
<br>
</pre>
<div class="txt"><pre>
    However, numbers stored in macros are not quite as precise as numbers
    stored in scalars.
<br>
    Scalars are stored in double precision (15-16 decimal digits), while
    locals have about 12 decimal digits, sometimes more, but never less than
    11.
<br>
    A scalar is a "container" containing one element, either a string or a
    number.
<br>
    It is good practice to use tempnames for scalars as they share the same
    namespace as variables
<br>
    <b>tempname</b> stores the names it reserves in a local macro, so we can use
    <b>st_local</b> to recover that.
<br>
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"><a href="#slide20.smcl">&lt;&lt;</a> <a href="#index.smcl">index</a> </a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="slide88.smcl">
<div class="txt"><pre>
<br>
                                  <b> References</b>
<br>
<a name="buis14"></a>    Buis, Maarten L. (2014), "Stata tip 120: Certifying subroutines", <i>Stata</i>
        <i>Journal</i>, <b>14</b>(2), pp. 449-450.
 
<a name="gould01"></a>    Gould, William W. (2001), "Statistical software certification", <i>Stata</i>
        <i>Journal</i>, <b>1</b>(1), pp. 29-50.
 
<a name="gould_etal10"></a>    Gould, William W.; Pitblado, Jeffrey; and Poi, Brian (2010), <i>Maximum</i>
        <i>Likelihood Estimation with Stata, Fourth Edition</i>.  College Station,
        TX: Stata Press.
 
 
-------------------------------------------------------------------------------
</pre>
<pre><p class="bottom"> <a href="#index.smcl">index</a> </a></pre>
<pre>
-------------------------------------------------------------------------------
</pre>
</div>
</div>
<div class="slide" id="app0">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>webuse hsng2, clear</code>
<code></code>
<code>gen byte cons = 1</code>
<code></code>
<code>gen byte touse = !missing(rent, pcturban, faminc, reg2, reg3, reg4, hsngval)</code>
<code></code>
<code>mata:</code>
<code>y = X = Z = .</code>
<code>st_view(y,.,"rent", "touse")</code>
<code>st_view(X,.,"hsngval pcturban cons", "touse")</code>
<code>st_view(Z,.,"pcturban faminc reg2 reg3 reg4 cons", "touse")</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide23.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app1">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>webuse hsng2, clear</code>
<code></code>
<code>gen byte cons = 1</code>
<code></code>
<code>gen byte touse = !missing(rent, pcturban, faminc, reg2, reg3, reg4, hsngval)</code>
<code></code>
<code>mata:</code>
<code>y = X = Z = .</code>
<code>st_view(y,.,"rent", "touse")</code>
<code>st_view(X,.,"hsngval pcturban cons", "touse")</code>
<code>st_view(Z,.,"pcturban faminc reg2 reg3 reg4 cons", "touse")</code>
<code></code>
<code>ZZi = invsym(cross(Z, Z))</code>
<code>M= Z*ZZi*Z'</code>
<code>b = invsym(X'*M*X)*X'*M*y</code>
<code>b</code>
<code>end</code>
<code></code>
<code>ivregress 2sls rent pcturban (hsngval = faminc i.region), small</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide25.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app2">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>webuse hsng2, clear</code>
<code></code>
<code>gen byte cons = 1</code>
<code></code>
<code>gen byte touse = !missing(rent, pcturban, faminc, reg2, reg3, reg4, hsngval)</code>
<code></code>
<code>mata:</code>
<code>y = X = Z = .</code>
<code>st_view(y,.,"rent", "touse")</code>
<code>st_view(X,.,"hsngval pcturban cons", "touse")</code>
<code>st_view(Z,.,"pcturban faminc reg2 reg3 reg4 cons", "touse")</code>
<code></code>
<code>ZZi = invsym(cross(Z, Z))</code>
<code>M= Z*ZZi*Z'</code>
<code>b = invsym(X'*M*X)*X'*M*y</code>
<code></code>
<code>k = cols(X) </code>
<code>N = rows(X)</code>
<code>res = y - X*b</code>
<code>ess = quadcross(res,res)</code>
<code>s2 = ess/(N-k)</code>
<code>Var = s2*invsym(X'*M*X)</code>
<code>sqrt(diagonal(Var))</code>
<code>end</code>
<code></code>
<code>ivregress 2sls rent pcturban (hsngval = faminc i.region), small</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide27.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app3">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>webuse hsng2, clear</code>
<code></code>
<code>gen byte cons = 1</code>
<code></code>
<code>gen byte touse = !missing(rent, pcturban, faminc, reg2, reg3, reg4, hsngval)</code>
<code></code>
<code>tempname b V</code>
<code></code>
<code>mata:</code>
<code>y = X = Z = .</code>
<code>st_view(y,.,"rent", "touse")</code>
<code>st_view(X,.,"hsngval pcturban cons", "touse")</code>
<code>st_view(Z,.,"pcturban faminc reg2 reg3 reg4 cons", "touse")</code>
<code></code>
<code>ZZi = invsym(cross(Z, Z))</code>
<code>M= Z*ZZi*Z'</code>
<code>b = invsym(X'*M*X)*X'*M*y</code>
<code></code>
<code>k = cols(X) </code>
<code>N = rows(X)</code>
<code>res = y - X*b</code>
<code>ess = quadcross(res,res)</code>
<code>s2 = ess/(N-k)</code>
<code>Var = s2*invsym(X'*M*X)</code>
<code>sqrt(diagonal(Var))</code>
<code></code>
<code>st_matrix(st_local("b"),b')</code>
<code>st_matrix(st_local("V"),Var)</code>
<code>st_local("df_r",strofreal(N-k))</code>
<code>st_local("N", strofreal(N))</code>
<code>end</code>
<code></code>
<code>local xnames `""pcturban" "faminc" "_cons""'</code>
<code>matrix colnames `b' = `xnames'</code>
<code>matrix colnames `V' = `xnames'</code>
<code>matrix rownames `V' = `xnames'</code>
<code>ereturn post `b' `V', dof(`df_r') obs(`N') esample(touse)</code>
<code>ereturn display</code>
<code></code>
<code>ivregress 2sls rent pcturban (hsngval = faminc i.region), small</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide29.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app4">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code></code>
<code>real scalar my_mean(string scalar varn)</code>
<code>{</code>
<code>    x = st_data(.,varn,0)</code>
<code>    return(sum(x)/rows(x))</code>
<code>}</code>
<code></code>
<code>end</code>
<code></code>
<code>sysuse auto</code>
<code>mata: my_mean("price")</code>
<code>sum price</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide31.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app5">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code></code>
<code>real scalar my_mean(string scalar varn)</code>
<code>{</code>
<code>    if (st_isnumvar(varn)==0) exit(error(108))</code>
<code>    x = st_data(.,varn,0)</code>
<code>    return(sum(x)/rows(x))</code>
<code>}</code>
<code></code>
<code>end</code>
<code></code>
<code>sysuse auto</code>
<code>mata: my_mean("price")</code>
<code>sum price</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide33.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app6">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code></code>
<code>real rowvector my_mean(string scalar varn)</code>
<code>{</code>
<code>    varn = tokens(varn)</code>
<code>    k = cols(varn)</code>
<code>    mean = J(1,k,.)</code>
<code>    for (i=1; i&lt;=k; i++) {</code>
<code>        if (st_isnumvar(varn[i])==0) exit(error(108))</code>
<code>        x = st_data(.,varn[i],0)</code>
<code>        mean[i] = sum(x)/rows(x)</code>
<code>    }</code>
<code>    return(mean)</code>
<code>}</code>
<code></code>
<code>end</code>
<code></code>
<code>sysuse auto</code>
<code>mata: my_mean("price mpg foreign rep78")</code>
<code>sum price mpg foreign rep78</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide35.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app7">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>real rowvector my_mean(string scalar varn)</code>
<code>{</code>
<code>    real scalar k, i</code>
<code>    real rowvector mean</code>
<code>    real colvector x</code>
<code>    </code>
<code>    varn = tokens(varn)</code>
<code>    k = cols(varn)</code>
<code>    mean = J(1,k,.)</code>
<code>    for (i=1; i&lt;=k; i++) {</code>
<code>        if (st_isnumvar(varn[i])==0) exit(error(108))</code>
<code>        x = st_data(.,varn[i],0)</code>
<code>        mean[i] = sum(x)/rows(x)</code>
<code>    }</code>
<code>    return(mean)</code>
<code>}</code>
<code></code>
<code>end</code>
<code></code>
<code>sysuse auto</code>
<code>mata: my_mean("price mpg foreign rep78")</code>
<code>sum price mpg foreign rep78</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide37.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app8">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>program drop _all</code>
<code>program define my_mean, rclass</code>
<code>    syntax varlist(numeric)</code>
<code>    tempname res</code>
<code>    mata:my_mean("`varlist'")</code>
<code>    matrix colnames `res' = `varlist'</code>
<code>    matrix rownames `res' = "mean"</code>
<code>    matlist `res'</code>
<code>    return matrix mean = `res'</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_mean(string scalar varn)</code>
<code>{</code>
<code>    real scalar k, i</code>
<code>    real rowvector mean</code>
<code>    real colvector x</code>
<code>    </code>
<code>    varn = tokens(varn)</code>
<code>    k = cols(varn)</code>
<code>    mean = J(1,k,.)</code>
<code>    for (i=1; i&lt;=k; i++) {</code>
<code>        x = st_data(.,varn[i],0)</code>
<code>        mean[i] = sum(x)/rows(x)</code>
<code>    }</code>
<code>    st_matrix(st_local("res"),mean)</code>
<code>}</code>
<code></code>
<code>end</code>
<code></code>
<code>sysuse auto</code>
<code>my_mean price mpg foreign rep78</code>
<code>sum price mpg foreign rep78</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide39.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app9">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>*! version 1.0.0 MLB 06Oct2021</code>
<code>program define my_mean06, rclass</code>
<code>    version 16</code>
<code>    syntax varlist(numeric)</code>
<code>    tempname res</code>
<code>    mata:my_mean("`varlist'")</code>
<code>    matrix colnames `res' = `varlist'</code>
<code>    matrix rownames `res' = "mean"</code>
<code>    matlist `res'</code>
<code>    return matrix mean = `res'</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_mean(string scalar varn)</code>
<code>{</code>
<code>    real scalar k, i</code>
<code>    real rowvector mean</code>
<code>    real colvector x</code>
<code>    </code>
<code>    varn = tokens(varn)</code>
<code>    k = cols(varn)</code>
<code>    mean = J(1,k,.)</code>
<code>    for (i=1; i&lt;=k; i++) {</code>
<code>        x = st_data(.,varn[i],0)</code>
<code>        mean[i] = sum(x)/rows(x)</code>
<code>    }</code>
<code>    st_matrix(st_local("res"),mean)</code>
<code>}</code>
<code></code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide41.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app10">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>webuse hsng2, clear</code>
<code></code>
<code>gen byte cons = 1</code>
<code></code>
<code>gen byte touse = !missing(rent, pcturban, faminc, reg2, reg3, reg4, hsngval)</code>
<code></code>
<code>tempname b V</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_2sls(string scalar depvar, string scalar exog, string scalar endog,</code>
<code>             string scalar instrum, string scalar cons, string scalar select)</code>
<code>{</code>
<code>	transmorphic y, X, Z</code>
<code>    string scalar Xnames, Znames</code>
<code>    real matrix ZZi, M, Var</code>
<code>    real colvector b, res</code>
<code>    real scalar k, N, ess, s2</code>
<code>    </code>
<code>    y = X = Z = .</code>
<code>    Xnames = endog + " " +  exog + " " + cons</code>
<code>    Znames = exog + " " + instrum + " " + cons</code>
<code>    st_view(y,.,depvar, select)</code>
<code>    st_view(X,.,Xnames, select)</code>
<code>    st_view(Z,.,Znames, select)</code>
<code></code>
<code>    ZZi = invsym(cross(Z, Z))</code>
<code>    M= Z*ZZi*Z'</code>
<code>    b = invsym(X'*M*X)*X'*M*y</code>
<code></code>
<code>    k = cols(X) </code>
<code>    N = rows(X)</code>
<code>    res = y - X*b</code>
<code>    ess = quadcross(res,res)</code>
<code>    s2 = ess/(N-k)</code>
<code>    Var = s2*invsym(X'*M*X)</code>
<code></code>
<code>    st_matrix(st_local("b"),b')</code>
<code>    st_matrix(st_local("V"),Var)</code>
<code>    st_local("df_r",strofreal(N-k))</code>
<code>    st_local("N", strofreal(N))</code>
<code>}</code>
<code>end</code>
<code></code>
<code></code>
<code>mata: my_2sls("rent", "pcturban", "hsngval", "faminc reg2 reg3 reg4", "cons", "touse")</code>
<code>local xnames `""pcturban" "faminc" "_cons""'</code>
<code>matrix colnames `b' = `xnames'</code>
<code>matrix colnames `V' = `xnames'</code>
<code>matrix rownames `V' = `xnames'</code>
<code>ereturn post `b' `V', dof(`df_r') obs(`N') esample(touse)</code>
<code>ereturn display</code>
<code></code>
<code>ivregress 2sls rent pcturban (hsngval = faminc i.region), small</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide43.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app11">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code></code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_2sls(string scalar depvar, string scalar exog, string scalar endog,</code>
<code>             string scalar instrum, string scalar cons, string scalar select)</code>
<code>{</code>
<code>	transmorphic y, X, Z</code>
<code>    string scalar Xnames, Znames</code>
<code>    real matrix ZZi, M, Var</code>
<code>    real colvector b, res</code>
<code>    real scalar k, N, ess, s2</code>
<code>    </code>
<code>    y = X = Z = .</code>
<code>    Xnames = endog + " " +  exog + " " + cons</code>
<code>    Znames = exog + " " + instrum + " " + cons</code>
<code>    st_view(y,.,depvar, select)</code>
<code>    st_view(X,.,Xnames, select)</code>
<code>    st_view(Z,.,Znames, select)</code>
<code></code>
<code>    ZZi = invsym(cross(Z, Z))</code>
<code>    M= Z*ZZi*Z'</code>
<code>    b = invsym(X'*M*X)*X'*M*y</code>
<code></code>
<code>    k = cols(X) </code>
<code>    N = rows(X)</code>
<code>    res = y - X*b</code>
<code>    ess = quadcross(res,res)</code>
<code>    s2 = ess/(N-k)</code>
<code>    Var = s2*invsym(X'*M*X)</code>
<code></code>
<code>    st_matrix(st_local("b"),b')</code>
<code>    st_matrix(st_local("V"),Var)</code>
<code>    st_local("df_r",strofreal(N-k))</code>
<code>    st_local("N", strofreal(N))</code>
<code>}</code>
<code>end</code>
<code></code>
<code>program drop _all</code>
<code>program define my_2sls, eclass</code>
<code>    syntax varlist(numeric) [if] [in], ///</code>
<code>         endog(varlist numeric)        ///</code>
<code>         instruments(varlist numeric)</code>
<code></code>
<code>    tempvar cons</code>
<code>    gen byte `cons' = 1</code>
<code></code>
<code>    gettoken y exog : varlist</code>
<code>    marksample touse</code>
<code>    </code>
<code>    tempname b V</code>
<code>    </code>
<code>    mata: my_2sls("`y'", "`exog'", "`endog'", "`instruments'", "`cons'", "`touse'")</code>
<code>    local xnames `exog' `endog'  "_cons"</code>
<code>    matrix colnames `b' = `xnames'</code>
<code>    matrix colnames `V' = `xnames'</code>
<code>    matrix rownames `V' = `xnames'</code>
<code>    ereturn post `b' `V', dof(`df_r') obs(`N') esample(`touse') depname("`y'")</code>
<code>    ereturn display</code>
<code>end</code>
<code></code>
<code>webuse hsng2, clear</code>
<code></code>
<code>my_2sls rent pcturban, endog(hsngval) instruments(faminc reg2 reg3 reg4)</code>
<code>ivregress 2sls rent pcturban (hsngval = faminc i.region), small</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide45.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app12">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>*! version 1.0.0 MLB 06Oct2021</code>
<code>program define my_2sls07, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(numeric) [if] [in], ///</code>
<code>         endog(varlist numeric)        ///</code>
<code>         instruments(varlist numeric)</code>
<code></code>
<code>    tempvar cons</code>
<code>    gen byte `cons' = 1</code>
<code></code>
<code>    gettoken y exog : varlist</code>
<code>    marksample touse</code>
<code>    </code>
<code>    tempname b V</code>
<code>    </code>
<code>    mata: my_2sls("`y'", "`exog'", "`endog'", "`instruments'", "`cons'", "`touse'")</code>
<code>    local xnames `exog' `endog'  "_cons"</code>
<code>    matrix colnames `b' = `xnames'</code>
<code>    matrix colnames `V' = `xnames'</code>
<code>    matrix rownames `V' = `xnames'</code>
<code>    ereturn post `b' `V', dof(`df_r') obs(`N') esample(`touse') depname("`y'")</code>
<code>    ereturn display</code>
<code>end</code>
<code></code>
<code></code>
<code>mata:</code>
<code>mata set matastrict on</code>
<code></code>
<code>void my_2sls(string scalar depvar, string scalar exog, string scalar endog,</code>
<code>             string scalar instrum, string scalar cons, string scalar select)</code>
<code>{</code>
<code>	transmorphic y, X, Z</code>
<code>    string scalar Xnames, Znames</code>
<code>    real matrix ZZi, M, Var</code>
<code>    real colvector b, res</code>
<code>    real scalar k, N, ess, s2</code>
<code>    </code>
<code>    y = X = Z = .</code>
<code>    Xnames = endog + " " +  exog + " " + cons</code>
<code>    Znames = exog + " " + instrum + " " + cons</code>
<code>    st_view(y,.,depvar, select)</code>
<code>    st_view(X,.,Xnames, select)</code>
<code>    st_view(Z,.,Znames, select)</code>
<code></code>
<code>    ZZi = invsym(cross(Z, Z))</code>
<code>    M= Z*ZZi*Z'</code>
<code>    b = invsym(X'*M*X)*X'*M*y</code>
<code></code>
<code>    k = cols(X) </code>
<code>    N = rows(X)</code>
<code>    res = y - X*b</code>
<code>    ess = quadcross(res,res)</code>
<code>    s2 = ess/(N-k)</code>
<code>    Var = s2*invsym(X'*M*X)</code>
<code></code>
<code>    st_matrix(st_local("b"),b')</code>
<code>    st_matrix(st_local("V"),Var)</code>
<code>    st_local("df_r",strofreal(N-k))</code>
<code>    st_local("N", strofreal(N))</code>
<code>}</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide47.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app13">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>use horse, clear</code>
<code>tab unit, gen(unit)</code>
<code>unab varl : unit2-unit14 // I am lazy </code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>// Step 1</code>
<code>void poissoneval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*xb - exp(xb) - lnfactorial(y)</code>
<code>}</code>
<code></code>
<code>// Step 2</code>
<code>M = moptimize_init()</code>
<code></code>
<code>// Step 3</code>
<code>moptimize_init_evaluator(M, &poissoneval())</code>
<code>moptimize_init_depvar(M, 1, "deaths")</code>
<code>moptimize_init_eq_indepvars(M,1,st_local("varl")) </code>
<code></code>
<code>// Step 4</code>
<code>moptimize(M)</code>
<code></code>
<code>// Step 5</code>
<code>moptimize_result_display(M)</code>
<code>end</code>
<code></code>
<code>poisson deaths i.unit</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide50.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app14">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>use horse, clear</code>
<code>tab unit, gen(unit)</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void poissoneval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*xb - exp(xb) - lnfactorial(y)</code>
<code>}</code>
<code></code>
<code>void poissonwork(string scalar depvar, string scalar indepvars)</code>
<code>{</code>
<code>    transmorphic M</code>
<code>    M = moptimize_init()</code>
<code>    moptimize_init_evaluatortype(M, "lf")</code>
<code>    moptimize_init_evaluator(M, &poissoneval())</code>
<code>    moptimize_init_touse(M, st_local("touse"))</code>
<code>    moptimize_init_ndepvars(M,1)</code>
<code>    moptimize_init_depvar(M, 1, depvar)</code>
<code>    moptimize_init_eq_indepvars(M,1,indepvars)</code>
<code>    moptimize_init_valueid(M, "log likelihood") </code>
<code>    moptimize(M)</code>
<code>    moptimize_result_display(M)</code>
<code>    moptimize_result_post(M)</code>
<code>}</code>
<code>end</code>
<code></code>
<code>program define my_poisson, eclass</code>
<code>    version 16</code>
<code>    syntax varlist [if] [in]</code>
<code>    </code>
<code>    marksample touse</code>
<code>    </code>
<code>    _rmcoll `varlist' if `touse'</code>
<code>    local varlist `r(varlist)'</code>
<code>    gettoken y x : varlist</code>
<code></code>
<code>    mata poissonwork("`y'", "`x'")</code>
<code>end</code>
<code></code>
<code>my_poisson deaths unit2-unit14</code>
<code>poisson deaths i.unit </code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide52.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app15">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>use horse, clear</code>
<code>tab unit, gen(unit)</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void poissoneval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*xb - exp(xb) - lnfactorial(y)</code>
<code>}</code>
<code></code>
<code>void poissonwork(string scalar depvar, string scalar indepvars)</code>
<code>{</code>
<code>    transmorphic M</code>
<code>    M = moptimize_init()</code>
<code>    moptimize_init_evaluatortype(M, "lf")</code>
<code>    moptimize_init_evaluator(M, &poissoneval())</code>
<code>    moptimize_init_touse(M, st_local("touse"))</code>
<code>    moptimize_init_ndepvars(M,1)</code>
<code>    moptimize_init_depvar(M, 1, depvar)</code>
<code>    moptimize_init_eq_indepvars(M,1,indepvars)</code>
<code>    moptimize_init_valueid(M, "log likelihood") </code>
<code>    moptimize(M)</code>
<code>    moptimize_result_display(M)</code>
<code>    moptimize_result_post(M)</code>
<code>}</code>
<code>end</code>
<code></code>
<code>program define my_poisson, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(fv ts) [if] [in]</code>
<code>    </code>
<code>    marksample touse</code>
<code>    </code>
<code>    _rmcoll `varlist' if `touse', expand</code>
<code>    local varlist `r(varlist)'</code>
<code>    gettoken y x : varlist</code>
<code>    _fv_check_depvar `y'</code>
<code>    </code>
<code>    mata poissonwork("`y'", "`x'")</code>
<code>end</code>
<code></code>
<code>my_poisson deaths i.unit</code>
<code>poisson deaths i.unit </code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide54.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app16">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>use horse, clear</code>
<code>program drop _all</code>
<code></code>
<code>program Startval, rclass</code>
<code>    syntax varname [if], k(integer) </code>
<code>    </code>
<code>    tempname b0</code>
<code>    matrix `b0' = J(1, `k', 0)</code>
<code>    </code>
<code>    marksample touse</code>
<code>    sum `varlist' if `touse', meanonly</code>
<code>    matrix `b0'[1,`k'] = ln(r(mean))</code>
<code>    return matrix b0 = `b0'</code>
<code>end</code>
<code></code>
<code>program define my_poisson, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(fv ts) [if] [in]</code>
<code>    </code>
<code>    marksample touse</code>
<code>    </code>
<code>    _rmcoll `varlist' if `touse', expand</code>
<code>    local varlist `r(varlist)'</code>
<code>    gettoken y x : varlist</code>
<code>    _fv_check_depvar `y'</code>
<code>    </code>
<code>    local k : word count `x'</code>
<code>    local k = `k' + 1</code>
<code>    Startval `y' if `touse', k(`k') `constant'</code>
<code>    </code>
<code>    mata poissonwork("`y'", "`x'")</code>
<code>end</code>
<code></code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void poissoneval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*xb - exp(xb) - lnfactorial(y)</code>
<code>}</code>
<code></code>
<code>void poissonwork(string scalar depvar, string scalar indepvars)</code>
<code>{</code>
<code>    transmorphic M</code>
<code>    M = moptimize_init()</code>
<code>    moptimize_init_evaluatortype(M, "lf")</code>
<code>    moptimize_init_evaluator(M, &poissoneval())</code>
<code>    moptimize_init_touse(M, st_local("touse"))</code>
<code>    moptimize_init_ndepvars(M,1)</code>
<code>    moptimize_init_depvar(M, 1, depvar)</code>
<code>    moptimize_init_eq_indepvars(M,1,indepvars)</code>
<code>    moptimize_init_valueid(M, "log likelihood") </code>
<code>    moptimize_init_eq_coefs(M,1,st_matrix("r(b0)"))</code>
<code>    moptimize_init_search(M, "off")    </code>
<code>    moptimize(M)</code>
<code>    moptimize_result_display(M)</code>
<code>    moptimize_result_post(M)</code>
<code>}</code>
<code>end</code>
<code></code>
<code></code>
<code>my_poisson deaths i.unit</code>
<code>poisson deaths i.unit </code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide56.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app17">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>program drop _all</code>
<code></code>
<code>program Startval, rclass</code>
<code>    syntax varname [if] [fweight pweight iweight/] , k(integer) </code>
<code>    </code>
<code>    if "`weight'" != "" local wgt [`weight' = `exp']</code>
<code>    if "`weight'" == "pweight" local wgt [aweight = `exp']</code>
<code>    </code>
<code>    tempname b0</code>
<code>    matrix `b0' = J(1, `k', 0)</code>
<code>    </code>
<code>    marksample touse</code>
<code>    sum `varlist' if `touse' `wgt', meanonly</code>
<code>    matrix `b0'[1,`k'] = ln(r(mean))</code>
<code>    return matrix b0 = `b0'</code>
<code>end</code>
<code></code>
<code>program define my_poisson, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(fv ts) [if] [in] [fweight pweight iweight/] </code>
<code>    </code>
<code>    if "`weight'" != "" local wgt [`weight' = `exp']</code>
<code>    marksample touse</code>
<code>    </code>
<code>    _rmcoll `varlist' if `touse' `wgt', expand</code>
<code>    local varlist `r(varlist)'</code>
<code>    gettoken y x : varlist</code>
<code>    _fv_check_depvar `y'</code>
<code>    </code>
<code>    local k : word count `x'</code>
<code>    local k = `k' + 1</code>
<code>    Startval `y' if `touse' `wgt', k(`k') `constant'</code>
<code>    </code>
<code>    mata poissonwork("`y'", "`x'")</code>
<code>end</code>
<code></code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>void poissoneval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*xb - exp(xb) - lnfactorial(y)</code>
<code>}</code>
<code></code>
<code>void poissonwork(string scalar depvar, string scalar indepvars)</code>
<code>{</code>
<code>    transmorphic M</code>
<code>    M = moptimize_init()</code>
<code>    moptimize_init_evaluatortype(M, "lf")</code>
<code>    moptimize_init_evaluator(M, &poissoneval())</code>
<code>    moptimize_init_ndepvars(M,1)</code>
<code>    moptimize_init_touse(M, st_local("touse"))</code>
<code>    moptimize_init_depvar(M, 1, depvar)</code>
<code>    moptimize_init_eq_indepvars(M,1,indepvars)</code>
<code>    if (st_local("weight") != "") {</code>
<code>     	moptimize_init_weighttype(M, st_local("weight"))</code>
<code>        moptimize_init_weight(M, st_local("exp"))</code>
<code>    }    </code>
<code>    moptimize_init_valueid(M, "log likelihood") </code>
<code>    moptimize_init_eq_coefs(M,1,st_matrix("r(b0)"))</code>
<code>    moptimize_init_search(M, "off")    </code>
<code>    moptimize(M)</code>
<code>    moptimize_result_display(M)</code>
<code>    moptimize_result_post(M)</code>
<code>}</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide58.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app18">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>*! version 1.0.0 MLB 06Oct2021</code>
<code>program define my_poisson, eclass</code>
<code>    version 16</code>
<code>    syntax varlist(fv ts) [if] [in] [fweight pweight iweight/] </code>
<code>    </code>
<code>    if "`weight'" != "" local wgt [`weight' = `exp']</code>
<code>    marksample touse</code>
<code>    </code>
<code>    _rmcoll `varlist' if `touse' `wgt', expand</code>
<code>    local varlist `r(varlist)'</code>
<code>    gettoken y x : varlist</code>
<code>    _fv_check_depvar `y'</code>
<code>    </code>
<code>    local k : word count `x'</code>
<code>    local k = `k' + 1</code>
<code>    Startval `y' if `touse' `wgt', k(`k') `constant'</code>
<code>    </code>
<code>    mata poissonwork("`y'", "`x'")</code>
<code>end</code>
<code></code>
<code>program Startval, rclass</code>
<code>    syntax varname [if] [fweight pweight iweight/] , k(integer) </code>
<code>    </code>
<code>    if "`weight'" != "" local wgt [`weight' = `exp']</code>
<code>    if "`weight'" == "pweight" local wgt [aweight = `exp']</code>
<code>    </code>
<code>    tempname b0</code>
<code>    matrix `b0' = J(1, `k', 0)</code>
<code>    </code>
<code>    marksample touse</code>
<code>    sum `varlist' if `touse' `wgt', meanonly</code>
<code>    matrix `b0'[1,`k'] = ln(r(mean))</code>
<code>    return matrix b0 = `b0'</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>mata set matastrict on</code>
<code></code>
<code>void poissoneval(transmorphic M, real rowvector b, real colvector lnf)</code>
<code>{</code>
<code>    real colvector xb</code>
<code>    real colvector y</code>
<code>    </code>
<code>    xb = moptimize_util_xb(M, b, 1)</code>
<code>    y  = moptimize_util_depvar(M,1)</code>
<code>    </code>
<code>    lnf = y:*xb - exp(xb) - lnfactorial(y)</code>
<code>}</code>
<code></code>
<code>void poissonwork(string scalar depvar, string scalar indepvars)</code>
<code>{</code>
<code>    transmorphic M</code>
<code>    M = moptimize_init()</code>
<code>    moptimize_init_evaluatortype(M, "lf")</code>
<code>    moptimize_init_evaluator(M, &poissoneval())</code>
<code>    moptimize_init_touse(M, st_local("touse"))</code>
<code>    moptimize_init_ndepvars(M,1)</code>
<code>    moptimize_init_depvar(M, 1, depvar)</code>
<code>    moptimize_init_eq_indepvars(M,1,indepvars)</code>
<code>    if (st_local("weight") != "") {</code>
<code>     	moptimize_init_weighttype(M, st_local("weight"))</code>
<code>        moptimize_init_weight(M, st_local("exp"))</code>
<code>    }    </code>
<code>    moptimize_init_valueid(M, "log likelihood") </code>
<code>    moptimize_init_eq_coefs(M,1,st_matrix("r(b0)"))</code>
<code>    moptimize_init_search(M, "off")    </code>
<code>    moptimize(M)</code>
<code>    moptimize_result_display(M)</code>
<code>    moptimize_result_post(M)</code>
<code>}</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide60.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app19">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>// the function we want to apprximate</code>
<code>real scalar curve(real scalar mu)</code>
<code>{</code>
<code>	real colvector y, lnL</code>
<code>	y = 0 \ 5 \ 2 \ 2 \ 4 \ 8 \ 1</code>
<code>    lnL = y:*ln(mu) :- mu :- lnfactorial(y)</code>
<code>	return(sum(lnL))</code>
<code>}</code>
<code></code>
<code>// the approximation</code>
<code>real matrix find_knots(pointer(real scalar function) p,   // new</code>
<code>                       real scalar lb, real scalar ub, </code>
<code>                       real scalar tol, real scalar maxiter)</code>
<code>{</code>
<code>	real matrix res </code>
<code>    real rowvector newknot</code>
<code>    real scalar i,j</code>
<code>    </code>
<code>    res = init_knots(p, lb, ub)                          // changed</code>
<code>    </code>
<code>    i = 1</code>
<code>    j= 0</code>
<code>    while (i &lt; rows(res) & j &lt; maxiter) {</code>
<code>    	j++</code>
<code>    	newknot = check_knot(p, res[i,.], res[i+1,.], tol)  //changed</code>
<code>        if (newknot != J(1,0,.)) {</code>
<code>            res = res[|1,1 \ i, 2|] \ newknot \ res[|i+1,1 \ .,2 |]</code>
<code>        }</code>
<code>        else {</code>
<code>        	i++</code>
<code>        }</code>
<code>    }</code>
<code>    if (j==maxiter) {</code>
<code>        exit(error(430))</code>
<code>    }</code>
<code>    return(res)</code>
<code>}</code>
<code></code>
<code>real matrix init_knots(pointer(real scalar function) p,  //new</code>
<code>                       real scalar lb, real scalar ub)</code>
<code>{</code>
<code>	real matrix res</code>
<code>    </code>
<code>    res = J(2,2,.)</code>
<code>    res[.,1] = lb \ ub</code>
<code>    res[1,2] = (*p)(lb)                                  //new</code>
<code>    res[2,2] = (*p)(ub)                                  //new  </code>
<code>    </code>
<code>    return(res)</code>
<code>}</code>
<code></code>
<code>real rowvector check_knot(pointer(real scalar function) p,  //new</code>
<code>                          rowvector lk, rowvector uk, real scalar tol)</code>
<code>{</code>
<code>	real scalar est, x, ref</code>
<code></code>
<code>    est = interp(lk[2], uk[2])</code>
<code>    x   = interp(lk[1], uk[1])</code>
<code>    ref = (*p)(x)                                        //new</code>
<code>    if (reldif(est,ref) &gt; tol) {</code>
<code>    	return((x,ref))</code>
<code>    }</code>
<code>    else{</code>
<code>    	return(J(1,0,.))</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>real scalar interp(real scalar lv, real scalar uv) </code>
<code>{</code>
<code>	return(lv + (uv-lv)/2)</code>
<code>}</code>
<code></code>
<code>real scalar eval_spline(real matrix sp, real scalar x)</code>
<code>{</code>
<code>	real scalar i, frac</code>
<code>    </code>
<code>    if (x == sp[rows(sp),1]) return(sp[rows(sp),2])</code>
<code>	</code>
<code>    i = find_x(sp,x)</code>
<code>    </code>
<code>    frac = (x - sp[i,1]) / (sp[i+1,1] - sp[i,1])</code>
<code>    </code>
<code>    return(sp[i,2] + frac* (sp[i+1,2] - sp[i,2]))</code>
<code>}</code>
<code></code>
<code>real scalar find_x(real matrix sp, real scalar x) </code>
<code>{</code>
<code>	real scalar i</code>
<code>    </code>
<code>    for(i=1; i &lt;= rows(sp); i++) {</code>
<code>    	if (sp[i,1] &gt;= x) break</code>
<code>    }</code>
<code>    </code>
<code>    if (i == rows(sp)) {</code>
<code>    	printf("x is out of range of sp")</code>
<code>    	exit(198)</code>
<code>    }</code>
<code>    </code>
<code>    return(i)</code>
<code>    </code>
<code>}</code>
<code>end</code>
<code>// example use</code>
<code>drop _all</code>
<code>mata:</code>
<code>sp = find_knots(&curve(),1e-5,10,1e-3,1000)</code>
<code></code>
<code>res = J(80,3,.)</code>
<code>for(i=1; i&lt;=80; i++) {</code>
<code>	j=i/10</code>
<code>    res[i,.] = (j, eval_spline(sp,j), curve(j))</code>
<code>}</code>
<code></code>
<code>nobs = st_nobs()</code>
<code>if (nobs &lt; 80) st_addobs(80-nobs)</code>
<code></code>
<code>idx = st_addvar("double", ("x","aprox", "actual"))</code>
<code>st_store(.,idx, res)</code>
<code></code>
<code>end</code>
<code></code>
<code>twoway line aprox actual x</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide65.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app20">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>A1 = 2, 5, 3 \</code>
<code>     2, 3, 9</code>
<code></code>
<code>A2 = 4, 6, 2 \</code>
<code>     1, 4, 2 </code>
<code>      </code>
<code>A3 = 6, 2, 7 \</code>
<code>     2, 5, 1       </code>
<code>     </code>
<code>threeD = J(3,1,NULL)</code>
<code>threeD[1] = &A1</code>
<code>threeD[2] = &A2</code>
<code>threeD[3] = &A3</code>
<code></code>
<code>(*threeD[2])[2,3]</code>
<code>end  </code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide68.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app21">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>// the function we want to apprximate</code>
<code>real scalar curve(real scalar mu)</code>
<code>{</code>
<code>	real colvector y, lnL</code>
<code>	y = 0 \ 5 \ 2 \ 2 \ 4 \ 8 \ 1</code>
<code>    lnL = y:*ln(mu) :- mu :- lnfactorial(y)</code>
<code>	return(sum(lnL))</code>
<code>}</code>
<code></code>
<code>// the approximation</code>
<code></code>
<code>struct sp_data {                                   //new</code>
<code>    real scalar lb, ub, tol, maxiter</code>
<code>    pointer(real scalar function) p</code>
<code>	real matrix sp</code>
<code>}</code>
<code></code>
<code>real matrix find_knots(pointer(real scalar function) p,   </code>
<code>                       real scalar lb, real scalar ub, </code>
<code>                       real scalar tol, real scalar maxiter)</code>
<code>{ </code>
<code>    real rowvector newknot</code>
<code>    real scalar i,j</code>
<code>    struct sp_data scalar data                      //new   </code>
<code></code>
<code>    data.lb     = lb                                //new </code>
<code>    data.ub     = ub                                //new </code>
<code>    data.tol    = tol                               //new</code>
<code>    data.maxiter= maxiter                           //new</code>
<code>    data.p      = p                                 //new</code>
<code>    </code>
<code>    data = init_knots(data)                          // changed</code>
<code></code>
<code>    i = 1</code>
<code>    j = 0</code>
<code>    while (i &lt; rows(data.sp) & j &lt; data.maxiter) {   //changed</code>
<code>    	j++</code>
<code>    	newknot = check_knot(data, i)                //changed</code>
<code>        if (newknot != J(1,0,.)) {</code>
<code>            data.sp = data.sp[|1,1 \ i, 2|] \ newknot \ data.sp[|i+1,1 \ .,2 |] //changed</code>
<code>        }</code>
<code>        else {</code>
<code>        	i++</code>
<code>        }</code>
<code>    }</code>
<code>    if (j==maxiter) {</code>
<code>        exit(error(430))</code>
<code>    }</code>
<code>    return(data.sp)                               //changed</code>
<code>}</code>
<code></code>
<code>struct sp_data scalar init_knots(struct sp_data scalar data)    //changed</code>
<code>{</code>
<code>    data.sp = J(2,2,.)</code>
<code>    data.sp[.,1] = data.lb \ data.ub</code>
<code>    data.sp[1,2] = (*data.p)(data.lb)                                  </code>
<code>    data.sp[2,2] = (*data.p)(data.ub)                                  </code>
<code>    </code>
<code>    return(data)</code>
<code>}</code>
<code></code>
<code>real rowvector check_knot(struct sp_data scalar data, real scalar i) // changed</code>
<code>{</code>
<code>	real scalar est, x, ref</code>
<code>    real rowvector lk, uk</code>
<code></code>
<code>    lk = data.sp[i,.]</code>
<code>    uk = data.sp[i+1, .]</code>
<code>    est = interp(lk[2], uk[2])</code>
<code>    x   = interp(lk[1], uk[1])</code>
<code>    ref = (*data.p)(x)     </code>
<code>    if (reldif(est,ref) &gt; data.tol) {</code>
<code>    	return((x,ref))</code>
<code>    }</code>
<code>    else{</code>
<code>    	return(J(1,0,.))</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>real scalar interp(real scalar lv, real scalar uv) </code>
<code>{</code>
<code>	return(lv + (uv-lv)/2)</code>
<code>}</code>
<code></code>
<code>real scalar eval_spline(real matrix sp, real scalar x)</code>
<code>{</code>
<code>	real scalar i, frac</code>
<code>    </code>
<code>    if (x == sp[rows(sp),1]) return(sp[rows(sp),2])</code>
<code>	</code>
<code>    i = find_x(sp,x)</code>
<code>    </code>
<code>    frac = (x - sp[i,1]) / (sp[i+1,1] - sp[i,1])</code>
<code>    </code>
<code>    return(sp[i,2] + frac* (sp[i+1,2] - sp[i,2]))</code>
<code>}</code>
<code></code>
<code>real scalar find_x(real matrix sp, real scalar x) </code>
<code>{</code>
<code>	real scalar i</code>
<code>    </code>
<code>    for(i=1; i &lt;= rows(sp); i++) {</code>
<code>    	if (sp[i,1] &gt;= x) break</code>
<code>    }</code>
<code>    </code>
<code>    if (i == rows(sp)) {</code>
<code>    	printf("x is out of range of sp")</code>
<code>    	exit(198)</code>
<code>    }</code>
<code>    </code>
<code>    return(i)</code>
<code>    </code>
<code>}</code>
<code>end</code>
<code>// example use</code>
<code>drop _all</code>
<code>mata:</code>
<code>sp = find_knots(&curve(),1e-5,10,1e-3,1000)</code>
<code></code>
<code>res = J(80,3,.)</code>
<code>for(i=1; i&lt;=80; i++) {</code>
<code>	j=i/10</code>
<code>    res[i,.] = (j, eval_spline(sp,j), curve(j))</code>
<code>}</code>
<code></code>
<code>nobs = st_nobs()</code>
<code>if (nobs &lt; 80) st_addobs(80-nobs)</code>
<code></code>
<code>idx = st_addvar("double", ("x","aprox", "actual"))</code>
<code>st_store(.,idx, res)</code>
<code></code>
<code>end</code>
<code></code>
<code>twoway line aprox actual x</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide72.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app22">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>// the function we want to apprximate</code>
<code>real scalar curve(real scalar mu)</code>
<code>{</code>
<code>	real colvector y, lnL</code>
<code>	y = 0 \ 5 \ 2 \ 2 \ 4 \ 8 \ 1</code>
<code>    lnL = y:*ln(mu) :- mu :- lnfactorial(y)</code>
<code>	return(sum(lnL))</code>
<code>}</code>
<code></code>
<code>// the approximation</code>
<code></code>
<code>class sp_approx {                                   //new</code>
<code>    real scalar lb, ub, tol, maxiter</code>
<code>    pointer(real scalar function) p</code>
<code>	real matrix sp</code>
<code>    </code>
<code>    real matrix find_knots()</code>
<code>    void        init_knots()</code>
<code>    real rowvector check_knot()</code>
<code>    real scalar interp()</code>
<code>    real scalar eval_spline()</code>
<code>    real scalar find_x()</code>
<code>}</code>
<code></code>
<code></code>
<code>real matrix sp_approx::find_knots(pointer(real scalar function) valp,   </code>
<code>                       real scalar vallb, real scalar valub, </code>
<code>                       real scalar valtol, real scalar valmaxiter)</code>
<code>{ </code>
<code>    real rowvector newknot</code>
<code>    real scalar i,j</code>
<code></code>
<code>    lb     = vallb                                </code>
<code>    ub     = valub                                </code>
<code>    tol    = valtol                               </code>
<code>    maxiter= valmaxiter                           </code>
<code>    p      = valp                                 </code>
<code>    </code>
<code>    init_knots()                                  </code>
<code></code>
<code>    i = 1</code>
<code>    j = 0</code>
<code>    while (i &lt; rows(sp) & j &lt; maxiter) {   </code>
<code>    	j++</code>
<code>    	newknot = check_knot(i)                </code>
<code>        if (newknot != J(1,0,.)) {</code>
<code>            sp = sp[|1,1 \ i, 2|] \ newknot \ sp[|i+1,1 \ .,2 |] </code>
<code>        }</code>
<code>        else {</code>
<code>        	i++</code>
<code>        }</code>
<code>    }</code>
<code>    if (j==maxiter) {</code>
<code>        exit(error(430))</code>
<code>    }</code>
<code>    return(sp)                               </code>
<code>}</code>
<code></code>
<code>void sp_approx::init_knots()    </code>
<code>{</code>
<code>    sp = J(2,2,.)</code>
<code>    sp[.,1] = lb \ ub</code>
<code>    sp[1,2] = (*p)(lb)                                  </code>
<code>    sp[2,2] = (*p)(ub)                                  </code>
<code>}</code>
<code></code>
<code>real rowvector sp_approx::check_knot(real scalar i) </code>
<code>{</code>
<code>	real scalar est, x, ref</code>
<code>    real rowvector lk, uk</code>
<code></code>
<code>    lk = sp[i,.]</code>
<code>    uk = sp[i+1, .]</code>
<code>    est = interp(lk[2], uk[2])</code>
<code>    x   = interp(lk[1], uk[1])</code>
<code>    ref = (*p)(x)     </code>
<code>    if (reldif(est,ref) &gt; tol) {</code>
<code>    	return((x,ref))</code>
<code>    }</code>
<code>    else{</code>
<code>    	return(J(1,0,.))</code>
<code>    }</code>
<code>}</code>
<code></code>
<code>real scalar sp_approx::interp(real scalar lv, real scalar uv) </code>
<code>{</code>
<code>	return(lv + (uv-lv)/2)</code>
<code>}</code>
<code></code>
<code>real scalar sp_approx::eval_spline(real scalar x)</code>
<code>{</code>
<code>	real scalar i, frac</code>
<code>    </code>
<code>    if (x == sp[rows(sp),1]) return(sp[rows(sp),2])</code>
<code>	</code>
<code>    i = find_x(x)</code>
<code>    </code>
<code>    frac = (x - sp[i,1]) / (sp[i+1,1] - sp[i,1])</code>
<code>    </code>
<code>    return(sp[i,2] + frac* (sp[i+1,2] - sp[i,2]))</code>
<code>}</code>
<code></code>
<code>real scalar sp_approx::find_x(real scalar x) </code>
<code>{</code>
<code>	real scalar i</code>
<code>    </code>
<code>    for(i=1; i &lt;= rows(sp); i++) {</code>
<code>    	if (sp[i,1] &gt;= x) break</code>
<code>    }</code>
<code>    </code>
<code>    if (i == rows(sp)) {</code>
<code>    	printf("x is out of range of sp")</code>
<code>    	exit(198)</code>
<code>    }</code>
<code>    </code>
<code>    return(i)</code>
<code>    </code>
<code>}</code>
<code>end</code>
<code>// example use</code>
<code>drop _all</code>
<code>mata:</code>
<code>sp = sp_approx()</code>
<code>sp.find_knots(&curve(),1e-5,10,1e-3,1000)</code>
<code></code>
<code>res = J(80,3,.)</code>
<code>for(i=1; i&lt;=80; i++) {</code>
<code>	j=i/10</code>
<code>    res[i,.] = (j, sp.eval_spline(j), curve(j))</code>
<code>}</code>
<code></code>
<code>nobs = st_nobs()</code>
<code>if (nobs &lt; 80) st_addobs(80-nobs)</code>
<code></code>
<code>idx = st_addvar("double", ("x","aprox", "actual"))</code>
<code>st_store(.,idx, res)</code>
<code></code>
<code>end</code>
<code></code>
<code>twoway line aprox actual x</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide75.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app23">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>hist = AssociativeArray()</code>
<code>hist.notfound(0)</code>
<code>fh = fopen("spd.txt", "r")</code>
<code>punct = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</code>
<code>punct = tokens(punct)</code>
<code></code>
<code>while ((line=fget(fh))!=J(0,0,"")) {</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    for (i=1; i &lt;= cols(line); i++) {</code>
<code>        freq = hist.get(line[i]) + 1</code>
<code>        hist.put(line[i], freq)</code>
<code>    }</code>
<code>}</code>
<code>fclose(fh)</code>
<code></code>
<code>hist.keys()[1..10,.]</code>
<code>hist.get("SPD")</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide78.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app24">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>hist = AssociativeArray()</code>
<code>hist.notfound(0)</code>
<code>fh = fopen("spd.txt", "r")</code>
<code>punct = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</code>
<code>punct = tokens(punct)</code>
<code></code>
<code>while ((line=fget(fh))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    for (i=1; i &lt;= cols(line); i++) {</code>
<code>        freq = hist.get(line[i]) + 1</code>
<code>        hist.put(line[i], freq)</code>
<code>    }</code>
<code>}</code>
<code>fclose(fh)</code>
<code></code>
<code>hist.keys()[1..10,.]</code>
<code>hist.get("spd")</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide79.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app25">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>stopwords = AssociativeArray()</code>
<code>fhs = fopen("stop_words_german.txt", "r")</code>
<code>while ((line=fget(fhs))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>	line = tokens(line)</code>
<code>	for(i=1; i &lt;=cols(line);i++) {</code>
<code>	    stopwords.put(line[i], 1)</code>
<code>	}</code>
<code>}</code>
<code>fclose(fhs)</code>
<code>	</code>
<code>hist = AssociativeArray()</code>
<code>hist.notfound(0)</code>
<code>fh = fopen("spd.txt", "r")</code>
<code>punct = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</code>
<code>punct = tokens(punct)</code>
<code></code>
<code>while ((line=fget(fh))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    for (i=1; i &lt;= cols(line); i++) {</code>
<code>	    if (!stopwords.exists(line[i])) {</code>
<code>			freq = hist.get(line[i]) + 1</code>
<code>			hist.put(line[i], freq)   </code>
<code>		}</code>
<code>    }</code>
<code>}</code>
<code>fclose(fh)</code>
<code></code>
<code>hist.keys()[1..10,.]</code>
<code>hist.get("spd")</code>
<code>hist.get("die")</code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide80.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app26">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>drop _all</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>stopwords = AssociativeArray()</code>
<code>fhs = fopen("stop_words_german.txt", "r")</code>
<code>while ((line=fget(fhs))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>	line = tokens(line)</code>
<code>	for(i=1; i &lt;=cols(line);i++) {</code>
<code>	    stopwords.put(line[i], 1)</code>
<code>	}</code>
<code>}</code>
<code>fclose(fhs)</code>
<code>	</code>
<code>hist = AssociativeArray()</code>
<code>hist.notfound(0)</code>
<code>fh = fopen("spd.txt", "r")</code>
<code>punct = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</code>
<code>punct = tokens(punct)</code>
<code></code>
<code>while ((line=fget(fh))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    for (i=1; i &lt;= cols(line); i++) {</code>
<code>	    if (!stopwords.exists(line[i])) {</code>
<code>			freq = hist.get(line[i]) + 1</code>
<code>			hist.put(line[i], freq)   </code>
<code>		}</code>
<code>    }</code>
<code>}</code>
<code>fclose(fh)</code>
<code></code>
<code>words = hist.keys()</code>
<code>k = rows(words)</code>
<code>count = J(k,1,.)</code>
<code>for(i=1; i&lt;=k; i++) {</code>
<code>    count[i] = hist.get(words[i])</code>
<code>}</code>
<code></code>
<code>o = order(count,1)</code>
<code>count = count[o,.]</code>
<code>words = words[o,.]</code>
<code></code>
<code>words[|k-20 \ k|]</code>
<code>count[|k-20 \ k|]</code>
<code></code>
<code>end</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide81.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app27">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>drop _all</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>stopwords = AssociativeArray()</code>
<code>fhs = fopen("stop_words_german.txt", "r")</code>
<code>while ((line=fget(fhs))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>	line = tokens(line)</code>
<code>	for(i=1; i &lt;=cols(line);i++) {</code>
<code>	    stopwords.put(line[i], 1)</code>
<code>	}</code>
<code>}</code>
<code>fclose(fhs)</code>
<code>	</code>
<code>hist = AssociativeArray()</code>
<code>hist.notfound(0)</code>
<code>fh = fopen("spd.txt", "r")</code>
<code>punct = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</code>
<code>punct = tokens(punct)</code>
<code></code>
<code>while ((line=fget(fh))!=J(0,0,"")) {</code>
<code>    line = strlower(line)</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    for (i=1; i &lt;= cols(line); i++) {</code>
<code>	    if (!stopwords.exists(line[i])) {</code>
<code>			freq = hist.get(line[i]) + 1</code>
<code>			hist.put(line[i], freq)   </code>
<code>		}</code>
<code>    }</code>
<code>}</code>
<code>fclose(fh)</code>
<code></code>
<code>words = hist.keys()</code>
<code>k = rows(words)</code>
<code>count = J(k,1,.)</code>
<code>for(i=1; i&lt;=k; i++) {</code>
<code>    count[i] = hist.get(words[i])</code>
<code>}</code>
<code></code>
<code>o = order(count,1)</code>
<code>count = count[o,.]</code>
<code>words = words[o,.]</code>
<code></code>
<code>if (st_nobs() &lt; k) {</code>
<code>    st_addobs(k-st_nobs())</code>
<code>}</code>
<code>maxl = max(strlen(words))</code>
<code>idx = st_addvar(maxl, "word")</code>
<code>st_sstore(.,idx, words)</code>
<code>idx = st_addvar("long","count")</code>
<code>st_store(., idx ,count)</code>
<code>end</code>
<code></code>
<code>// most common words</code>
<code>list in -20/L</code>
<code></code>
<code>//average length of words</code>
<code>gen len = ustrlen(word)</code>
<code>sum len [fw=count]</code>
<code></code>
<code>// a "Gini plot" for words</code>
<code>gen rel = count / r(N)</code>
<code>replace rel = sum(rel)</code>
<code>gen ref = _n/_N</code>
<code></code>
<code>twoway line rel ref, aspect(1) || ///</code>
<code>       function reference = x</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide82.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app28">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>drop _all</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>class hist_gen {</code>
<code>    string                  scalar    fn_stopwords</code>
<code>	class  AssociativeArray scalar    stopwords</code>
<code>	string                  scalar    fn</code>
<code>	class  AssociativeArray scalar    hist</code>
<code>	string                  rowvector punct</code>
<code>	</code>
<code>	void                              setup()</code>
<code>    void                              parse_stopwords()</code>
<code>	void                              make_hist()</code>
<code>	string                  rowvector parse_line()</code>
<code>	real                    scalar    valid_word()</code>
<code>	void                              count_words() </code>
<code>	void                              to_stata()</code>
<code>}</code>
<code></code>
<code>void hist_gen::parse_stopwords() </code>
<code>{</code>
<code>    real scalar fh, i</code>
<code>    string rowvector line, EOF</code>
<code>    </code>
<code>    EOF = J(0,0,"")</code>
<code>    </code>
<code>    fh = fopen(fn_stopwords, "r")</code>
<code>    while ( (line=fget(fh)) != EOF ) {</code>
<code>        line = strlower(line)</code>
<code>        line = tokens(line)</code>
<code>        for(i=1; i &lt;=cols(line);i++) {</code>
<code>            stopwords.put(line[i], 1)</code>
<code>        }</code>
<code>    }</code>
<code>    fclose(fh)</code>
<code>}</code>
<code></code>
<code>void hist_gen::setup() </code>
<code>{</code>
<code>	parse_stopwords()</code>
<code>    punct = tokens(punct)    </code>
<code>}</code>
<code></code>
<code>void hist_gen::make_hist()</code>
<code>{</code>
<code>	setup()</code>
<code>    count_words()</code>
<code>}	</code>
<code></code>
<code>void hist_gen::count_words()</code>
<code>{</code>
<code>	string rowvector EOF, line</code>
<code>    real scalar fh, i, freq</code>
<code>    </code>
<code>    EOF = J(0,0,"")</code>
<code>    </code>
<code>    hist.notfound(0)</code>
<code>    fh = fopen(fn, "r") </code>
<code>    </code>
<code>    while ((line=fget(fh))!=EOF) {</code>
<code>    	line = parse_line(line)</code>
<code>        for (i=1; i &lt;= cols(line); i++) {</code>
<code>            if (valid_word(line[i])) {</code>
<code>                freq = hist.get(line[i]) + 1</code>
<code>                hist.put(line[i], freq)   </code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>    fclose(fh)</code>
<code>}</code>
<code></code>
<code>string rowvector hist_gen::parse_line(string scalar line)</code>
<code>{</code>
<code>	real scalar i</code>
<code>    </code>
<code>    line = strlower(line)</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    return(line)</code>
<code>}</code>
<code></code>
<code>real scalar hist_gen::valid_word(string scalar word)</code>
<code>{</code>
<code>	return(!stopwords.exists(word))</code>
<code>}</code>
<code></code>
<code>void hist_gen::to_stata()</code>
<code>{</code>
<code>	string colvector words</code>
<code>    real   colvector count, o</code>
<code>    real   scalar    k, i, maxl, idx</code>
<code>    words = hist.keys()</code>
<code>    k = rows(words)</code>
<code>    count = J(k,1,.)</code>
<code>    for(i=1; i&lt;=k; i++) {</code>
<code>        count[i] = hist.get(words[i])</code>
<code>    }</code>
<code></code>
<code>    o = order(count,1)</code>
<code>    count = count[o,.]</code>
<code>    words = words[o,.]</code>
<code></code>
<code>    if (st_nobs() &lt; k) {</code>
<code>        st_addobs(k-st_nobs())</code>
<code>    }</code>
<code>    maxl = max(strlen(words))</code>
<code>    idx = st_addvar(maxl, "word")</code>
<code>    st_sstore(.,idx, words)</code>
<code>    idx = st_addvar("long","count")</code>
<code>    st_store(., idx ,count)</code>
<code>}</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>hist = hist_gen()</code>
<code>hist.fn           = "spd.txt"</code>
<code>hist.fn_stopwords = "stop_words_german.txt"</code>
<code>hist.punct        = `", . ; : ! ? ( ) [ ] &gt; &lt; - – * "'</code>
<code>hist.make_hist()</code>
<code>hist.to_stata()</code>
<code>end</code>
<code></code>
<code>sort count</code>
<code>list in -20/L</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide83.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div><div class="slide" id="app29">
<pre><p align="center"><b>(solution)</b></p></pre><br><br>
<pre class="code">
<code>drop _all</code>
<code></code>
<code>mata:</code>
<code>mata clear</code>
<code>mata set matastrict on</code>
<code></code>
<code>class hist_gen {</code>
<code>    string                  scalar    fn_stopwords</code>
<code>	class  AssociativeArray scalar    stopwords</code>
<code>	string                  scalar    fn</code>
<code>	class  AssociativeArray scalar    hist</code>
<code>	string                  rowvector punct</code>
<code>	</code>
<code>    transmorphic                      fn_stopwords()</code>
<code>    transmorphic                      fn()</code>
<code>    transmorphic                      punct()</code>
<code>	void                              setup()</code>
<code>    void                              parse_stopwords()</code>
<code>	void                              make_hist()</code>
<code>	string                  rowvector parse_line()</code>
<code>	real                    scalar    valid_word()</code>
<code>	void                              count_words() </code>
<code>	void                              to_stata()</code>
<code>}</code>
<code></code>
<code>transmorphic hist_gen::fn_stopwords(| string scalar val)</code>
<code>{</code>
<code>	if (args() == 1) {</code>
<code>    	fn_stopwords = val</code>
<code>    }</code>
<code>    else {</code>
<code>    	return(fn_stopwords)</code>
<code>    }</code>
<code>}</code>
<code>transmorphic hist_gen::fn(| string scalar val)</code>
<code>{</code>
<code>	if (args() == 1) {</code>
<code>    	fn = val</code>
<code>    }</code>
<code>    else {</code>
<code>    	return(fn)</code>
<code>    }</code>
<code>}</code>
<code>transmorphic hist_gen::punct(| string scalar val)</code>
<code>{</code>
<code>	if (args() == 1) {</code>
<code>    	punct = val</code>
<code>    }</code>
<code>    else {</code>
<code>    	return(punct)</code>
<code>    }</code>
<code>}</code>
<code>void hist_gen::parse_stopwords() </code>
<code>{</code>
<code>    real scalar fh, i</code>
<code>    string rowvector line, EOF</code>
<code>    </code>
<code>    EOF = J(0,0,"")</code>
<code>    </code>
<code>    fh = fopen(fn_stopwords, "r")</code>
<code>    while ( (line=fget(fh)) != EOF ) {</code>
<code>        line = strlower(line)</code>
<code>        line = tokens(line)</code>
<code>        for(i=1; i &lt;=cols(line);i++) {</code>
<code>            stopwords.put(line[i], 1)</code>
<code>        }</code>
<code>    }</code>
<code>    fclose(fh)</code>
<code>}</code>
<code></code>
<code>void hist_gen::setup() </code>
<code>{</code>
<code>	parse_stopwords()</code>
<code>    punct = tokens(punct)    </code>
<code>}</code>
<code></code>
<code>void hist_gen::make_hist()</code>
<code>{</code>
<code>	setup()</code>
<code>    count_words()</code>
<code>}	</code>
<code></code>
<code>void hist_gen::count_words()</code>
<code>{</code>
<code>	string rowvector EOF, line</code>
<code>    real scalar fh, i, freq</code>
<code>    </code>
<code>    EOF = J(0,0,"")</code>
<code>    </code>
<code>    hist.notfound(0)</code>
<code>    fh = fopen(fn, "r") </code>
<code>    </code>
<code>    while ((line=fget(fh))!=EOF) {</code>
<code>    	line = parse_line(line)</code>
<code>        for (i=1; i &lt;= cols(line); i++) {</code>
<code>            if (valid_word(line[i])) {</code>
<code>                freq = hist.get(line[i]) + 1</code>
<code>                hist.put(line[i], freq)   </code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>    fclose(fh)</code>
<code>}</code>
<code></code>
<code>string rowvector hist_gen::parse_line(string scalar line)</code>
<code>{</code>
<code>	real scalar i</code>
<code>    </code>
<code>    line = strlower(line)</code>
<code>    for(i=1; i&lt;= cols(punct); i++) {</code>
<code>		line = usubinstr(line,punct[i], "",.)</code>
<code>	}</code>
<code>    line = tokens(line)</code>
<code>    return(line)</code>
<code>}</code>
<code></code>
<code>real scalar hist_gen::valid_word(string scalar word)</code>
<code>{</code>
<code>	return(!stopwords.exists(word))</code>
<code>}</code>
<code></code>
<code>void hist_gen::to_stata()</code>
<code>{</code>
<code>	string colvector words</code>
<code>    real   colvector count, o</code>
<code>    real   scalar    k, i, maxl, idx</code>
<code>    words = hist.keys()</code>
<code>    k = rows(words)</code>
<code>    count = J(k,1,.)</code>
<code>    for(i=1; i&lt;=k; i++) {</code>
<code>        count[i] = hist.get(words[i])</code>
<code>    }</code>
<code></code>
<code>    o = order(count,1)</code>
<code>    count = count[o,.]</code>
<code>    words = words[o,.]</code>
<code></code>
<code>    if (st_nobs() &lt; k) {</code>
<code>        st_addobs(k-st_nobs())</code>
<code>    }</code>
<code>    maxl = max(strlen(words))</code>
<code>    idx = st_addvar(maxl, "word")</code>
<code>    st_sstore(.,idx, words)</code>
<code>    idx = st_addvar("long","count")</code>
<code>    st_store(., idx ,count)</code>
<code>}</code>
<code>end</code>
<code></code>
<code>mata:</code>
<code>hist = hist_gen()</code>
<code>hist.fn("spd.txt")</code>
<code>hist.fn_stopwords("stop_words_german.txt")</code>
<code>hist.punct(`", . ; : ! ? ( ) [ ] &gt; &lt; - – * "')</code>
<code>hist.make_hist()</code>
<code>hist.to_stata()</code>
<code>end</code>
<code></code>
<code>sort count</code>
<code>list in -20/L</code>
</pre>
<div class="txt"></p><pre>-------------------------------------------------------------------------------</pre>
<pre><p align=center><a href="#slide84.smcl">&lt;&lt;</a></p></pre>
<pre>-------------------------------------------------------------------------------</pre>
</div></div>
</body>
</html>
